#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import jnpr.jet.jnxBase_jnx_addr.ttypes
import jnpr.jet.routing_prpd_common.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class RoutingLabelStackEntryWellKnownLabels:
  IPV4_EXPLICIT_NULL_LABEL = 0
  ROUTER_ALERT_LABEL = 1
  IPV6_EXPLICIT_NULL_LABEL = 2
  IMPLICIT_NULL_LABEL = 3

  _VALUES_TO_NAMES = {
    0: "IPV4_EXPLICIT_NULL_LABEL",
    1: "ROUTER_ALERT_LABEL",
    2: "IPV6_EXPLICIT_NULL_LABEL",
    3: "IMPLICIT_NULL_LABEL",
  }

  _NAMES_TO_VALUES = {
    "IPV4_EXPLICIT_NULL_LABEL": 0,
    "ROUTER_ALERT_LABEL": 1,
    "IPV6_EXPLICIT_NULL_LABEL": 2,
    "IMPLICIT_NULL_LABEL": 3,
  }

class RoutingBgpRouteInitializeReplyBgpRouteInitializeStatus:
  SUCCESS = 0
  SUCCESS_STATE_REBOUND = 1
  INTERNAL_ERROR = 2
  ALREADY_INITIALIZED = 3
  GATEWAY_INVALID = 4
  CLEANUP_PENDING = 5

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "SUCCESS_STATE_REBOUND",
    2: "INTERNAL_ERROR",
    3: "ALREADY_INITIALIZED",
    4: "GATEWAY_INVALID",
    5: "CLEANUP_PENDING",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "SUCCESS_STATE_REBOUND": 1,
    "INTERNAL_ERROR": 2,
    "ALREADY_INITIALIZED": 3,
    "GATEWAY_INVALID": 4,
    "CLEANUP_PENDING": 5,
  }

class RoutingBgpRouteCleanupReplyBgpRouteCleanupStatus:
  SUCCESS = 0
  INTERNAL_ERROR = 1
  NOT_INITIALIZED = 2

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "INTERNAL_ERROR",
    2: "NOT_INITIALIZED",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "INTERNAL_ERROR": 1,
    "NOT_INITIALIZED": 2,
  }

class RoutingBgpRouteOperReplyBgpRouteOperStatus:
  SUCCESS = 0
  INTERNAL_ERROR = 1
  NOT_INITIALIZED = 2
  NO_OP = 3
  TOO_MANY_OPS = 4
  TABLE_INVALID = 5
  TABLE_NOT_READY = 6
  PREFIX_INVALID = 7
  PREFIX_LEN_TOO_SHORT = 8
  PREFIX_LEN_TOO_LONG = 9
  GATEWAY_INVALID = 10
  NEXTHOP_INVALID = 11
  NEXTHOP_ADDRESS_INVALID = 12
  NEXTHOP_ECMP_LIMIT = 13
  COMMUNITY_LIST_INVALID = 14
  ASPATH_INVALID = 15
  LABEL_INFO_INVALID = 16
  ROUTE_EXISTS = 17
  ROUTE_NOT_FOUND = 18
  CLUSTER_LIST_INVALID = 19
  PROTOCOL_INVALID = 20
  ROUTE_ADD_FAILED = 21
  BGP_NOT_READY = 22
  TRY_AGAIN = 23
  REQUEST_UNSUPPORTED = 24

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "INTERNAL_ERROR",
    2: "NOT_INITIALIZED",
    3: "NO_OP",
    4: "TOO_MANY_OPS",
    5: "TABLE_INVALID",
    6: "TABLE_NOT_READY",
    7: "PREFIX_INVALID",
    8: "PREFIX_LEN_TOO_SHORT",
    9: "PREFIX_LEN_TOO_LONG",
    10: "GATEWAY_INVALID",
    11: "NEXTHOP_INVALID",
    12: "NEXTHOP_ADDRESS_INVALID",
    13: "NEXTHOP_ECMP_LIMIT",
    14: "COMMUNITY_LIST_INVALID",
    15: "ASPATH_INVALID",
    16: "LABEL_INFO_INVALID",
    17: "ROUTE_EXISTS",
    18: "ROUTE_NOT_FOUND",
    19: "CLUSTER_LIST_INVALID",
    20: "PROTOCOL_INVALID",
    21: "ROUTE_ADD_FAILED",
    22: "BGP_NOT_READY",
    23: "TRY_AGAIN",
    24: "REQUEST_UNSUPPORTED",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "INTERNAL_ERROR": 1,
    "NOT_INITIALIZED": 2,
    "NO_OP": 3,
    "TOO_MANY_OPS": 4,
    "TABLE_INVALID": 5,
    "TABLE_NOT_READY": 6,
    "PREFIX_INVALID": 7,
    "PREFIX_LEN_TOO_SHORT": 8,
    "PREFIX_LEN_TOO_LONG": 9,
    "GATEWAY_INVALID": 10,
    "NEXTHOP_INVALID": 11,
    "NEXTHOP_ADDRESS_INVALID": 12,
    "NEXTHOP_ECMP_LIMIT": 13,
    "COMMUNITY_LIST_INVALID": 14,
    "ASPATH_INVALID": 15,
    "LABEL_INFO_INVALID": 16,
    "ROUTE_EXISTS": 17,
    "ROUTE_NOT_FOUND": 18,
    "CLUSTER_LIST_INVALID": 19,
    "PROTOCOL_INVALID": 20,
    "ROUTE_ADD_FAILED": 21,
    "BGP_NOT_READY": 22,
    "TRY_AGAIN": 23,
    "REQUEST_UNSUPPORTED": 24,
  }

class RoutingBgpRouteGetReplyBgpRouteGetStatus:
  SUCCESS = 0
  INTERNAL_ERROR = 1
  NOT_INITIALIZED = 2
  TABLE_INVALID = 3
  TABLE_NOT_READY = 4
  PREFIX_INVALID = 5
  PREFIX_LEN_TOO_SHORT = 6
  PREFIX_LEN_TOO_LONG = 7
  ROUTE_NOT_FOUND = 8
  PROTOCOL_INVALID = 9
  ROUTE_INVALID = 10
  REQUEST_UNSUPPORTED = 11
  TRY_AGAIN = 12
  ROUTE_COUNT_INVALID = 13

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "INTERNAL_ERROR",
    2: "NOT_INITIALIZED",
    3: "TABLE_INVALID",
    4: "TABLE_NOT_READY",
    5: "PREFIX_INVALID",
    6: "PREFIX_LEN_TOO_SHORT",
    7: "PREFIX_LEN_TOO_LONG",
    8: "ROUTE_NOT_FOUND",
    9: "PROTOCOL_INVALID",
    10: "ROUTE_INVALID",
    11: "REQUEST_UNSUPPORTED",
    12: "TRY_AGAIN",
    13: "ROUTE_COUNT_INVALID",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "INTERNAL_ERROR": 1,
    "NOT_INITIALIZED": 2,
    "TABLE_INVALID": 3,
    "TABLE_NOT_READY": 4,
    "PREFIX_INVALID": 5,
    "PREFIX_LEN_TOO_SHORT": 6,
    "PREFIX_LEN_TOO_LONG": 7,
    "ROUTE_NOT_FOUND": 8,
    "PROTOCOL_INVALID": 9,
    "ROUTE_INVALID": 10,
    "REQUEST_UNSUPPORTED": 11,
    "TRY_AGAIN": 12,
    "ROUTE_COUNT_INVALID": 13,
  }

class RoutingRouteProtocol:
  PROTO_UNSPECIFIED = 0
  PROTO_BGP = 1
  PROTO_BGP_STATIC = 2

  _VALUES_TO_NAMES = {
    0: "PROTO_UNSPECIFIED",
    1: "PROTO_BGP",
    2: "PROTO_BGP_STATIC",
  }

  _NAMES_TO_VALUES = {
    "PROTO_UNSPECIFIED": 0,
    "PROTO_BGP": 1,
    "PROTO_BGP_STATIC": 2,
  }

class RoutingRouteOperation:
  UNSPECIFIED = 0
  NO_ADVERTISE = 1
  NO_EXPORT = 2
  USE_NH_REJECT = 4

  _VALUES_TO_NAMES = {
    0: "UNSPECIFIED",
    1: "NO_ADVERTISE",
    2: "NO_EXPORT",
    4: "USE_NH_REJECT",
  }

  _NAMES_TO_VALUES = {
    "UNSPECIFIED": 0,
    "NO_ADVERTISE": 1,
    "NO_EXPORT": 2,
    "USE_NH_REJECT": 4,
  }


class RoutingBgpAttrib32:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpAttrib32')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpAttrib64:
  """
  Attributes:
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
  )

  def __init__(self, value=None,):
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpAttrib64')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingLabelStackEntry:
  """
  Attributes:
   - label_value
   - exp_value
   - ttl_value
   - bottom_of_stack
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'label_value', None, None, ), # 1
    (2, TType.STRING, 'exp_value', None, None, ), # 2
    (3, TType.STRING, 'ttl_value', None, None, ), # 3
    (4, TType.BOOL, 'bottom_of_stack', None, None, ), # 4
  )

  def __init__(self, label_value=None, exp_value=None, ttl_value=None, bottom_of_stack=None,):
    self.label_value = label_value
    self.exp_value = exp_value
    self.ttl_value = ttl_value
    self.bottom_of_stack = bottom_of_stack

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.label_value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.exp_value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ttl_value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.bottom_of_stack = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingLabelStackEntry')
    if self.label_value is not None:
      oprot.writeFieldBegin('label_value', TType.STRING, 1)
      oprot.writeString(self.label_value)
      oprot.writeFieldEnd()
    if self.exp_value is not None:
      oprot.writeFieldBegin('exp_value', TType.STRING, 2)
      oprot.writeString(self.exp_value)
      oprot.writeFieldEnd()
    if self.ttl_value is not None:
      oprot.writeFieldBegin('ttl_value', TType.STRING, 3)
      oprot.writeString(self.ttl_value)
      oprot.writeFieldEnd()
    if self.bottom_of_stack is not None:
      oprot.writeFieldBegin('bottom_of_stack', TType.BOOL, 4)
      oprot.writeBool(self.bottom_of_stack)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingLabelStack:
  """
  Attributes:
   - entries
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'entries', (TType.STRUCT,(RoutingLabelStackEntry, RoutingLabelStackEntry.thrift_spec)), None, ), # 1
  )

  def __init__(self, entries=None,):
    self.entries = entries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.entries = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = RoutingLabelStackEntry()
            _elem5.read(iprot)
            self.entries.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingLabelStack')
    if self.entries is not None:
      oprot.writeFieldBegin('entries', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.entries))
      for iter6 in self.entries:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingCommunity:
  """
  Attributes:
   - community_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'community_string', None, None, ), # 1
  )

  def __init__(self, community_string=None,):
    self.community_string = community_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.community_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingCommunity')
    if self.community_string is not None:
      oprot.writeFieldBegin('community_string', TType.STRING, 1)
      oprot.writeString(self.community_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingCommunityList:
  """
  Attributes:
   - com_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'com_list', (TType.STRUCT,(RoutingCommunity, RoutingCommunity.thrift_spec)), None, ), # 1
  )

  def __init__(self, com_list=None,):
    self.com_list = com_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.com_list = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = RoutingCommunity()
            _elem12.read(iprot)
            self.com_list.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingCommunityList')
    if self.com_list is not None:
      oprot.writeFieldBegin('com_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.com_list))
      for iter13 in self.com_list:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingAsPath:
  """
  Attributes:
   - aspath_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'aspath_string', None, None, ), # 1
  )

  def __init__(self, aspath_string=None,):
    self.aspath_string = aspath_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.aspath_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingAsPath')
    if self.aspath_string is not None:
      oprot.writeFieldBegin('aspath_string', TType.STRING, 1)
      oprot.writeString(self.aspath_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteMatch:
  """
  Attributes:
   - dest_prefix
   - dest_prefix_len
   - table
   - protocol
   - path_cookie
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dest_prefix', (jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix, jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dest_prefix_len', None, None, ), # 2
    (3, TType.STRUCT, 'table', (jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable, jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable.thrift_spec), None, ), # 3
    (4, TType.I32, 'protocol', None, None, ), # 4
    (5, TType.STRING, 'path_cookie', None, None, ), # 5
  )

  def __init__(self, dest_prefix=None, dest_prefix_len=None, table=None, protocol=None, path_cookie=None,):
    self.dest_prefix = dest_prefix
    self.dest_prefix_len = dest_prefix_len
    self.table = table
    self.protocol = protocol
    self.path_cookie = path_cookie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dest_prefix = jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix()
          self.dest_prefix.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dest_prefix_len = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.table = jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.protocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.path_cookie = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteMatch')
    if self.dest_prefix is not None:
      oprot.writeFieldBegin('dest_prefix', TType.STRUCT, 1)
      self.dest_prefix.write(oprot)
      oprot.writeFieldEnd()
    if self.dest_prefix_len is not None:
      oprot.writeFieldBegin('dest_prefix_len', TType.STRING, 2)
      oprot.writeString(self.dest_prefix_len)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 3)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    if self.protocol is not None:
      oprot.writeFieldBegin('protocol', TType.I32, 4)
      oprot.writeI32(self.protocol)
      oprot.writeFieldEnd()
    if self.path_cookie is not None:
      oprot.writeFieldBegin('path_cookie', TType.STRING, 5)
      oprot.writeString(self.path_cookie)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BgpRouteEntryLabelInfo:
  """
  Attributes:
   - vpn_label
   - labels
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRING, 'vpn_label', None, None, ), # 10
    (11, TType.STRUCT, 'labels', (RoutingLabelStack, RoutingLabelStack.thrift_spec), None, ), # 11
  )

  def __init__(self, vpn_label=None, labels=None,):
    self.vpn_label = vpn_label
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 10:
        if ftype == TType.STRING:
          self.vpn_label = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.labels = RoutingLabelStack()
          self.labels.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BgpRouteEntryLabelInfo')
    if self.vpn_label is not None:
      oprot.writeFieldBegin('vpn_label', TType.STRING, 10)
      oprot.writeString(self.vpn_label)
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.STRUCT, 11)
      self.labels.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteEntry:
  """
  Attributes:
   - dest_prefix
   - dest_prefix_len
   - table
   - protocol
   - path_cookie
   - route_preference
   - local_preference
   - med
   - aigp_distance
   - communities
   - aspath
   - originator_id
   - cluster_list
   - cluster_id
   - route_oper_flag
   - protocol_nexthops
   - LabelInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dest_prefix', (jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix, jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dest_prefix_len', None, None, ), # 2
    (3, TType.STRUCT, 'table', (jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable, jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable.thrift_spec), None, ), # 3
    (4, TType.I32, 'protocol', None, None, ), # 4
    (5, TType.STRING, 'path_cookie', None, None, ), # 5
    (6, TType.STRUCT, 'route_preference', (RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'local_preference', (RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'med', (RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'aigp_distance', (RoutingBgpAttrib64, RoutingBgpAttrib64.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'LabelInfo', (BgpRouteEntryLabelInfo, BgpRouteEntryLabelInfo.thrift_spec), None, ), # 10
    None, # 11
    (12, TType.STRUCT, 'communities', (RoutingCommunityList, RoutingCommunityList.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'aspath', (RoutingAsPath, RoutingAsPath.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'originator_id', (RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec), None, ), # 14
    (15, TType.LIST, 'cluster_list', (TType.STRUCT,(RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec)), None, ), # 15
    (16, TType.STRUCT, 'cluster_id', (RoutingBgpAttrib32, RoutingBgpAttrib32.thrift_spec), None, ), # 16
    (17, TType.STRING, 'route_oper_flag', None, None, ), # 17
    (18, TType.LIST, 'protocol_nexthops', (TType.STRUCT,(jnpr.jet.jnxBase_jnx_addr.ttypes.JnxBaseIpAddress, jnpr.jet.jnxBase_jnx_addr.ttypes.JnxBaseIpAddress.thrift_spec)), None, ), # 18
  )

  def __init__(self, dest_prefix=None, dest_prefix_len=None, table=None, protocol=None, path_cookie=None, route_preference=None, local_preference=None, med=None, aigp_distance=None, communities=None, aspath=None, originator_id=None, cluster_list=None, cluster_id=None, route_oper_flag=None, protocol_nexthops=None, LabelInfo=None,):
    self.dest_prefix = dest_prefix
    self.dest_prefix_len = dest_prefix_len
    self.table = table
    self.protocol = protocol
    self.path_cookie = path_cookie
    self.route_preference = route_preference
    self.local_preference = local_preference
    self.med = med
    self.aigp_distance = aigp_distance
    self.communities = communities
    self.aspath = aspath
    self.originator_id = originator_id
    self.cluster_list = cluster_list
    self.cluster_id = cluster_id
    self.route_oper_flag = route_oper_flag
    self.protocol_nexthops = protocol_nexthops
    self.LabelInfo = LabelInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dest_prefix = jnpr.jet.routing_prpd_common.ttypes.RoutingRoutePrefix()
          self.dest_prefix.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dest_prefix_len = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.table = jnpr.jet.routing_prpd_common.ttypes.RoutingRouteTable()
          self.table.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.protocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.path_cookie = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.route_preference = RoutingBgpAttrib32()
          self.route_preference.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.local_preference = RoutingBgpAttrib32()
          self.local_preference.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.med = RoutingBgpAttrib32()
          self.med.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.aigp_distance = RoutingBgpAttrib64()
          self.aigp_distance.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.communities = RoutingCommunityList()
          self.communities.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.aspath = RoutingAsPath()
          self.aspath.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.originator_id = RoutingBgpAttrib32()
          self.originator_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.cluster_list = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = RoutingBgpAttrib32()
            _elem19.read(iprot)
            self.cluster_list.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.cluster_id = RoutingBgpAttrib32()
          self.cluster_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.route_oper_flag = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.LIST:
          self.protocol_nexthops = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = jnpr.jet.jnxBase_jnx_addr.ttypes.JnxBaseIpAddress()
            _elem25.read(iprot)
            self.protocol_nexthops.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.LabelInfo = BgpRouteEntryLabelInfo()
          self.LabelInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteEntry')
    if self.dest_prefix is not None:
      oprot.writeFieldBegin('dest_prefix', TType.STRUCT, 1)
      self.dest_prefix.write(oprot)
      oprot.writeFieldEnd()
    if self.dest_prefix_len is not None:
      oprot.writeFieldBegin('dest_prefix_len', TType.STRING, 2)
      oprot.writeString(self.dest_prefix_len)
      oprot.writeFieldEnd()
    if self.table is not None:
      oprot.writeFieldBegin('table', TType.STRUCT, 3)
      self.table.write(oprot)
      oprot.writeFieldEnd()
    if self.protocol is not None:
      oprot.writeFieldBegin('protocol', TType.I32, 4)
      oprot.writeI32(self.protocol)
      oprot.writeFieldEnd()
    if self.path_cookie is not None:
      oprot.writeFieldBegin('path_cookie', TType.STRING, 5)
      oprot.writeString(self.path_cookie)
      oprot.writeFieldEnd()
    if self.route_preference is not None:
      oprot.writeFieldBegin('route_preference', TType.STRUCT, 6)
      self.route_preference.write(oprot)
      oprot.writeFieldEnd()
    if self.local_preference is not None:
      oprot.writeFieldBegin('local_preference', TType.STRUCT, 7)
      self.local_preference.write(oprot)
      oprot.writeFieldEnd()
    if self.med is not None:
      oprot.writeFieldBegin('med', TType.STRUCT, 8)
      self.med.write(oprot)
      oprot.writeFieldEnd()
    if self.aigp_distance is not None:
      oprot.writeFieldBegin('aigp_distance', TType.STRUCT, 9)
      self.aigp_distance.write(oprot)
      oprot.writeFieldEnd()
    if self.LabelInfo is not None:
      oprot.writeFieldBegin('LabelInfo', TType.STRUCT, 10)
      self.LabelInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.communities is not None:
      oprot.writeFieldBegin('communities', TType.STRUCT, 12)
      self.communities.write(oprot)
      oprot.writeFieldEnd()
    if self.aspath is not None:
      oprot.writeFieldBegin('aspath', TType.STRUCT, 13)
      self.aspath.write(oprot)
      oprot.writeFieldEnd()
    if self.originator_id is not None:
      oprot.writeFieldBegin('originator_id', TType.STRUCT, 14)
      self.originator_id.write(oprot)
      oprot.writeFieldEnd()
    if self.cluster_list is not None:
      oprot.writeFieldBegin('cluster_list', TType.LIST, 15)
      oprot.writeListBegin(TType.STRUCT, len(self.cluster_list))
      for iter26 in self.cluster_list:
        iter26.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cluster_id is not None:
      oprot.writeFieldBegin('cluster_id', TType.STRUCT, 16)
      self.cluster_id.write(oprot)
      oprot.writeFieldEnd()
    if self.route_oper_flag is not None:
      oprot.writeFieldBegin('route_oper_flag', TType.STRING, 17)
      oprot.writeString(self.route_oper_flag)
      oprot.writeFieldEnd()
    if self.protocol_nexthops is not None:
      oprot.writeFieldBegin('protocol_nexthops', TType.LIST, 18)
      oprot.writeListBegin(TType.STRUCT, len(self.protocol_nexthops))
      for iter27 in self.protocol_nexthops:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteInitializeRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteInitializeRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteInitializeReply:
  """
  Attributes:
   - status
   - gw_n_routes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.STRING, 'gw_n_routes', None, None, ), # 2
  )

  def __init__(self, status=None, gw_n_routes=None,):
    self.status = status
    self.gw_n_routes = gw_n_routes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.gw_n_routes = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteInitializeReply')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.gw_n_routes is not None:
      oprot.writeFieldBegin('gw_n_routes', TType.STRING, 2)
      oprot.writeString(self.gw_n_routes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteCleanupRequest:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteCleanupRequest')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteCleanupReply:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteCleanupReply')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteUpdateRequest:
  """
  Attributes:
   - bgp_routes
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'bgp_routes', (TType.STRUCT,(RoutingBgpRouteEntry, RoutingBgpRouteEntry.thrift_spec)), None, ), # 1
  )

  def __init__(self, bgp_routes=None,):
    self.bgp_routes = bgp_routes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.bgp_routes = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = RoutingBgpRouteEntry()
            _elem33.read(iprot)
            self.bgp_routes.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteUpdateRequest')
    if self.bgp_routes is not None:
      oprot.writeFieldBegin('bgp_routes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.bgp_routes))
      for iter34 in self.bgp_routes:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteRemoveRequest:
  """
  Attributes:
   - or_longer
   - bgp_routes
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'or_longer', None, None, ), # 1
    (2, TType.LIST, 'bgp_routes', (TType.STRUCT,(RoutingBgpRouteMatch, RoutingBgpRouteMatch.thrift_spec)), None, ), # 2
  )

  def __init__(self, or_longer=None, bgp_routes=None,):
    self.or_longer = or_longer
    self.bgp_routes = bgp_routes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.or_longer = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.bgp_routes = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = RoutingBgpRouteMatch()
            _elem40.read(iprot)
            self.bgp_routes.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteRemoveRequest')
    if self.or_longer is not None:
      oprot.writeFieldBegin('or_longer', TType.BOOL, 1)
      oprot.writeBool(self.or_longer)
      oprot.writeFieldEnd()
    if self.bgp_routes is not None:
      oprot.writeFieldBegin('bgp_routes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.bgp_routes))
      for iter41 in self.bgp_routes:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteGetRequest:
  """
  Attributes:
   - bgp_route
   - or_longer
   - active_only
   - reply_address_format
   - reply_table_format
   - route_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bgp_route', (RoutingBgpRouteMatch, RoutingBgpRouteMatch.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'or_longer', None, None, ), # 2
    (3, TType.BOOL, 'active_only', None, None, ), # 3
    (4, TType.I32, 'reply_address_format', None, None, ), # 4
    (5, TType.I32, 'reply_table_format', None, None, ), # 5
    (6, TType.STRING, 'route_count', None, None, ), # 6
  )

  def __init__(self, bgp_route=None, or_longer=None, active_only=None, reply_address_format=None, reply_table_format=None, route_count=None,):
    self.bgp_route = bgp_route
    self.or_longer = or_longer
    self.active_only = active_only
    self.reply_address_format = reply_address_format
    self.reply_table_format = reply_table_format
    self.route_count = route_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bgp_route = RoutingBgpRouteMatch()
          self.bgp_route.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.or_longer = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.active_only = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.reply_address_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.reply_table_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.route_count = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteGetRequest')
    if self.bgp_route is not None:
      oprot.writeFieldBegin('bgp_route', TType.STRUCT, 1)
      self.bgp_route.write(oprot)
      oprot.writeFieldEnd()
    if self.or_longer is not None:
      oprot.writeFieldBegin('or_longer', TType.BOOL, 2)
      oprot.writeBool(self.or_longer)
      oprot.writeFieldEnd()
    if self.active_only is not None:
      oprot.writeFieldBegin('active_only', TType.BOOL, 3)
      oprot.writeBool(self.active_only)
      oprot.writeFieldEnd()
    if self.reply_address_format is not None:
      oprot.writeFieldBegin('reply_address_format', TType.I32, 4)
      oprot.writeI32(self.reply_address_format)
      oprot.writeFieldEnd()
    if self.reply_table_format is not None:
      oprot.writeFieldBegin('reply_table_format', TType.I32, 5)
      oprot.writeI32(self.reply_table_format)
      oprot.writeFieldEnd()
    if self.route_count is not None:
      oprot.writeFieldBegin('route_count', TType.STRING, 6)
      oprot.writeString(self.route_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteOperReply:
  """
  Attributes:
   - status
   - operations_completed
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.STRING, 'operations_completed', None, None, ), # 2
  )

  def __init__(self, status=None, operations_completed=None,):
    self.status = status
    self.operations_completed = operations_completed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operations_completed = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteOperReply')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.operations_completed is not None:
      oprot.writeFieldBegin('operations_completed', TType.STRING, 2)
      oprot.writeString(self.operations_completed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoutingBgpRouteGetReply:
  """
  Attributes:
   - status
   - bgp_routes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.LIST, 'bgp_routes', (TType.STRUCT,(RoutingBgpRouteEntry, RoutingBgpRouteEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, status=None, bgp_routes=None,):
    self.status = status
    self.bgp_routes = bgp_routes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.bgp_routes = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = RoutingBgpRouteEntry()
            _elem47.read(iprot)
            self.bgp_routes.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoutingBgpRouteGetReply')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.bgp_routes is not None:
      oprot.writeFieldBegin('bgp_routes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.bgp_routes))
      for iter48 in self.bgp_routes:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
