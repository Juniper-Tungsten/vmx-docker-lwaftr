#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import jnpr.jet.shared.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ConfigFormatType:
  """
  Config Format Type
  """
  CONFIG_FORMAT_TEXT = 1
  CONFIG_FORMAT_SET = 2
  CONFIG_FORMAT_XML = 3

  _VALUES_TO_NAMES = {
    1: "CONFIG_FORMAT_TEXT",
    2: "CONFIG_FORMAT_SET",
    3: "CONFIG_FORMAT_XML",
  }

  _NAMES_TO_VALUES = {
    "CONFIG_FORMAT_TEXT": 1,
    "CONFIG_FORMAT_SET": 2,
    "CONFIG_FORMAT_XML": 3,
  }

class ConfigLoadType:
  """
  Config load type
  """
  CONFIG_LOAD_REPLACE = 0
  CONFIG_LOAD_MERGE = 1
  CONFIG_LOAD_OVERRIDE = 2
  CONFIG_LOAD_UPDATE = 3

  _VALUES_TO_NAMES = {
    0: "CONFIG_LOAD_REPLACE",
    1: "CONFIG_LOAD_MERGE",
    2: "CONFIG_LOAD_OVERRIDE",
    3: "CONFIG_LOAD_UPDATE",
  }

  _NAMES_TO_VALUES = {
    "CONFIG_LOAD_REPLACE": 0,
    "CONFIG_LOAD_MERGE": 1,
    "CONFIG_LOAD_OVERRIDE": 2,
    "CONFIG_LOAD_UPDATE": 3,
  }

class ConfigCommitType:
  """
  Config commit type
  """
  CONFIG_COMMIT_SYNCHRONIZE = 0
  CONFIG_COMMIT = 1
  CONFIG_COMMIT_AT = 2
  CONFIG_COMMIT_CONFIRMED = 3

  _VALUES_TO_NAMES = {
    0: "CONFIG_COMMIT_SYNCHRONIZE",
    1: "CONFIG_COMMIT",
    2: "CONFIG_COMMIT_AT",
    3: "CONFIG_COMMIT_CONFIRMED",
  }

  _NAMES_TO_VALUES = {
    "CONFIG_COMMIT_SYNCHRONIZE": 0,
    "CONFIG_COMMIT": 1,
    "CONFIG_COMMIT_AT": 2,
    "CONFIG_COMMIT_CONFIRMED": 3,
  }

class ConfigDatabaseType:
  """
  Database Type
  """
  CONFIG_DB_SHARED = 0
  CONFIG_DB_BATCH = 2
  CONFIG_DB_EPHEMERAL = 3

  _VALUES_TO_NAMES = {
    0: "CONFIG_DB_SHARED",
    2: "CONFIG_DB_BATCH",
    3: "CONFIG_DB_EPHEMERAL",
  }

  _NAMES_TO_VALUES = {
    "CONFIG_DB_SHARED": 0,
    "CONFIG_DB_BATCH": 2,
    "CONFIG_DB_EPHEMERAL": 3,
  }

class OperationFormatType:
  """
  Output format
  """
  OPERATION_FORMAT_JSON = 0
  OPERATION_FORMAT_XML = 1
  OPERATION_FORMAT_CLI = 2

  _VALUES_TO_NAMES = {
    0: "OPERATION_FORMAT_JSON",
    1: "OPERATION_FORMAT_XML",
    2: "OPERATION_FORMAT_CLI",
  }

  _NAMES_TO_VALUES = {
    "OPERATION_FORMAT_JSON": 0,
    "OPERATION_FORMAT_XML": 1,
    "OPERATION_FORMAT_CLI": 2,
  }


class ConfigCommit:
  """
  Configuration Commit options to be filled.

  Attributes:
   - commit_type: Commit type, default is ConfigCommitType.CONFIG_COMMIT_SYNCHRONIZE
   - comment: commit comment
   - attribute: If commit_type is just CONFIG_COMMIT then attribute will have
  date/time at which commit to be carried out whose values can
  be reboot or time with format of type "hh:mm[:ss]" or "yyyy-mm-dd hh:mm[:ss]".
  If commit_type is CONFIG_COMMIT_AT then attribute will provide delay interval
  for committing the configuration.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'commit_type', None,     0, ), # 1
    (2, TType.STRING, 'comment', None, "", ), # 2
    (3, TType.STRING, 'attribute', None, "", ), # 3
  )

  def __init__(self, commit_type=thrift_spec[1][4], comment=thrift_spec[2][4], attribute=thrift_spec[3][4],):
    self.commit_type = commit_type
    self.comment = comment
    self.attribute = attribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.commit_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.attribute = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigCommit')
    if self.commit_type is not None:
      oprot.writeFieldBegin('commit_type', TType.I32, 1)
      oprot.writeI32(self.commit_type)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.attribute is not None:
      oprot.writeFieldBegin('attribute', TType.STRING, 3)
      oprot.writeString(self.attribute)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigLoadCommit:
  """
  Configuration load commit main structure

  Attributes:
   - config: Config string of type set, xml, text
   - format: Config string type set, xml or text
   - database: Database type, default is ConfigDatabaseType.CONFIG_DB_SHARED
   - load_type: Configuration load type, default is ConfigLoadType.CONFIG_LOAD_MERGE
   - commit: Commit type, default is ConfigCommitType.CONFIG_COMMIT_SYNCHRONIZE
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'config', None, None, ), # 1
    (2, TType.I32, 'format', None,     3, ), # 2
    (3, TType.I32, 'database', None,     0, ), # 3
    (4, TType.I32, 'load_type', None,     1, ), # 4
    (5, TType.STRUCT, 'commit', (ConfigCommit, ConfigCommit.thrift_spec), None, ), # 5
  )

  def __init__(self, config=None, format=thrift_spec[2][4], database=thrift_spec[3][4], load_type=thrift_spec[4][4], commit=None,):
    self.config = config
    self.format = format
    self.database = database
    self.load_type = load_type
    self.commit = commit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.config = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.database = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.load_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.commit = ConfigCommit()
          self.commit.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigLoadCommit')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRING, 1)
      oprot.writeString(self.config)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 2)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.I32, 3)
      oprot.writeI32(self.database)
      oprot.writeFieldEnd()
    if self.load_type is not None:
      oprot.writeFieldBegin('load_type', TType.I32, 4)
      oprot.writeI32(self.load_type)
      oprot.writeFieldEnd()
    if self.commit is not None:
      oprot.writeFieldBegin('commit', TType.STRUCT, 5)
      self.commit.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.config is None:
      raise TProtocol.TProtocolException(message='Required field config is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OperationCommand:
  """
  Operational command structure

  Attributes:
   - command: Command input
   - in_format: Input format, default is JSON
   - out_format: Output format, default is JSON
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'command', None, None, ), # 1
    (2, TType.I32, 'in_format', None,     0, ), # 2
    (3, TType.I32, 'out_format', None,     0, ), # 3
  )

  def __init__(self, command=None, in_format=thrift_spec[2][4], out_format=thrift_spec[3][4],):
    self.command = command
    self.in_format = in_format
    self.out_format = out_format

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.command = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.in_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.out_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OperationCommand')
    if self.command is not None:
      oprot.writeFieldBegin('command', TType.STRING, 1)
      oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.in_format is not None:
      oprot.writeFieldBegin('in_format', TType.I32, 2)
      oprot.writeI32(self.in_format)
      oprot.writeFieldEnd()
    if self.out_format is not None:
      oprot.writeFieldBegin('out_format', TType.I32, 3)
      oprot.writeI32(self.out_format)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.command is None:
      raise TProtocol.TProtocolException(message='Required field command is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class OperationResponse:
  """
  Operational response structure

  Attributes:
   - status: Error status
   - response: Interfaces
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (jnpr.jet.shared.ttypes.RetStatus, jnpr.jet.shared.ttypes.RetStatus.thrift_spec), None, ), # 1
    (2, TType.STRING, 'response', None, None, ), # 2
  )

  def __init__(self, status=None, response=None,):
    self.status = status
    self.response = response

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = jnpr.jet.shared.ttypes.RetStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.response = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('OperationResponse')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.response is not None:
      oprot.writeFieldBegin('response', TType.STRING, 2)
      oprot.writeString(self.response)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EphemeralConfig:
  """
  Epheral options for client session

  Attributes:
   - eph_name: Ephemeral instance name
   - delete_on_disconnect: Option to delete ephemeral configuration on disconnect
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'eph_name', None, None, ), # 1
    (2, TType.BOOL, 'delete_on_disconnect', None, False, ), # 2
  )

  def __init__(self, eph_name=None, delete_on_disconnect=thrift_spec[2][4],):
    self.eph_name = eph_name
    self.delete_on_disconnect = delete_on_disconnect

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.eph_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.delete_on_disconnect = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EphemeralConfig')
    if self.eph_name is not None:
      oprot.writeFieldBegin('eph_name', TType.STRING, 1)
      oprot.writeString(self.eph_name)
      oprot.writeFieldEnd()
    if self.delete_on_disconnect is not None:
      oprot.writeFieldBegin('delete_on_disconnect', TType.BOOL, 2)
      oprot.writeBool(self.delete_on_disconnect)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.eph_name is None:
      raise TProtocol.TProtocolException(message='Required field eph_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
