#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import jnpr.jet.shared.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class FamilyType:
  """
  Enum for indicating the interface status
  """
  af_unspec = 0
  af_inet = 1

  _VALUES_TO_NAMES = {
    0: "af_unspec",
    1: "af_inet",
  }

  _NAMES_TO_VALUES = {
    "af_unspec": 0,
    "af_inet": 1,
  }

class NextHopType:
  """
  Next hop type
  """
  RNH_RECEIVE = 0

  _VALUES_TO_NAMES = {
    0: "RNH_RECEIVE",
  }

  _NAMES_TO_VALUES = {
    "RNH_RECEIVE": 0,
  }

class ProtocolType:
  """
  Protocol type
  """
  STATIC = 0

  _VALUES_TO_NAMES = {
    0: "STATIC",
  }

  _NAMES_TO_VALUES = {
    "STATIC": 0,
  }


class GatewayAddress:
  """
  Union to provide gateway IP or mac
  address for next hop address
  currently only nexthop address is supported

  Attributes:
   - nexthop_ip: Gateway IP
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nexthop_ip', None, None, ), # 1
  )

  def __init__(self, nexthop_ip=None,):
    self.nexthop_ip = nexthop_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nexthop_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GatewayAddress')
    if self.nexthop_ip is not None:
      oprot.writeFieldBegin('nexthop_ip', TType.STRING, 1)
      oprot.writeString(self.nexthop_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NexthopInfo:
  """
  Route Qualified Nexthop structure
  will have either gateway_ip or ethernet_mac filled.

  Attributes:
   - nexthop_address: Nexthop address
   - if_name: Interface name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'nexthop_address', (GatewayAddress, GatewayAddress.thrift_spec), None, ), # 1
    (2, TType.STRING, 'if_name', None, None, ), # 2
  )

  def __init__(self, nexthop_address=None, if_name=None,):
    self.nexthop_address = nexthop_address
    self.if_name = if_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.nexthop_address = GatewayAddress()
          self.nexthop_address.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.if_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NexthopInfo')
    if self.nexthop_address is not None:
      oprot.writeFieldBegin('nexthop_address', TType.STRUCT, 1)
      self.nexthop_address.write(oprot)
      oprot.writeFieldEnd()
    if self.if_name is not None:
      oprot.writeFieldBegin('if_name', TType.STRING, 2)
      oprot.writeString(self.if_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nexthop_address is None:
      raise TProtocol.TProtocolException(message='Required field nexthop_address is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RouteInfo:
  """
  Route structure

  Attributes:
   - prefix: Route prefix with prefix length  separated by '/'  example: 10.20.30.40/32
   - preference: Route preference value
   - metrics: Metrics
   - owner: Route owner, default is system
   - nexthops: Nexthop list.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'prefix', None, None, ), # 1
    (2, TType.LIST, 'preference', (TType.I32,None), None, ), # 2
    (3, TType.LIST, 'metrics', (TType.I32,None), None, ), # 3
    (4, TType.STRING, 'owner', None, None, ), # 4
    (5, TType.LIST, 'nexthops', (TType.STRUCT,(NexthopInfo, NexthopInfo.thrift_spec)), None, ), # 5
  )

  def __init__(self, prefix=None, preference=None, metrics=None, owner=None, nexthops=None,):
    self.prefix = prefix
    self.preference = preference
    self.metrics = metrics
    self.owner = owner
    self.nexthops = nexthops

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prefix = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.preference = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32();
            self.preference.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.metrics = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readI32();
            self.metrics.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.nexthops = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = NexthopInfo()
            _elem17.read(iprot)
            self.nexthops.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RouteInfo')
    if self.prefix is not None:
      oprot.writeFieldBegin('prefix', TType.STRING, 1)
      oprot.writeString(self.prefix)
      oprot.writeFieldEnd()
    if self.preference is not None:
      oprot.writeFieldBegin('preference', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.preference))
      for iter18 in self.preference:
        oprot.writeI32(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metrics is not None:
      oprot.writeFieldBegin('metrics', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.metrics))
      for iter19 in self.metrics:
        oprot.writeI32(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 4)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.nexthops is not None:
      oprot.writeFieldBegin('nexthops', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.nexthops))
      for iter20 in self.nexthops:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RetRoutes:
  """
  Struct for return values of RouteGet API

  Attributes:
   - status: Error status
   - table_name: Route table name
   - routes: Routes in the table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (jnpr.jet.shared.ttypes.RetStatus, jnpr.jet.shared.ttypes.RetStatus.thrift_spec), None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'routes', (TType.STRUCT,(RouteInfo, RouteInfo.thrift_spec)), None, ), # 3
  )

  def __init__(self, status=None, table_name=None, routes=None,):
    self.status = status
    self.table_name = table_name
    self.routes = routes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = jnpr.jet.shared.ttypes.RetStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.routes = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = RouteInfo()
            _elem26.read(iprot)
            self.routes.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RetRoutes')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.routes is not None:
      oprot.writeFieldBegin('routes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.routes))
      for iter27 in self.routes:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RouteConfig:
  """
  Route config object used for add/delete routes.
  For delete operation nexthops, route_state, protocol are not used

  Attributes:
   - app_id: optional application id
   - family_type: family type
   - route_prefix: with prefix and length prefix/length
   - next_hoptype: Next hop type
   - nexthops: Qualified next hops
   - route_state: Route states ROUTE_STATE_INTERIOR, ...
   - table_name: Table name, default is inet.0
   - preference: Preference,
   - metric: Metric
   - protocol: protocol name access/access-internal/static, default static
   - route_flags: Route flags like ROUTE_FLAG_ADD_PROXY_ARP, ..
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'app_id', None, None, ), # 1
    (2, TType.I32, 'family_type', None, None, ), # 2
    (3, TType.STRING, 'route_prefix', None, None, ), # 3
    (4, TType.I32, 'next_hoptype', None,     0, ), # 4
    (5, TType.LIST, 'nexthops', (TType.STRUCT,(NexthopInfo, NexthopInfo.thrift_spec)), None, ), # 5
    (6, TType.I32, 'route_state', None, 1, ), # 6
    (7, TType.STRING, 'table_name', None, None, ), # 7
    (8, TType.LIST, 'preference', (TType.I32,None), None, ), # 8
    (9, TType.LIST, 'metric', (TType.I32,None), None, ), # 9
    (10, TType.I32, 'protocol', None, None, ), # 10
    (11, TType.I32, 'route_flags', None, 1, ), # 11
  )

  def __init__(self, app_id=None, family_type=None, route_prefix=None, next_hoptype=thrift_spec[4][4], nexthops=None, route_state=thrift_spec[6][4], table_name=None, preference=None, metric=None, protocol=None, route_flags=thrift_spec[11][4],):
    self.app_id = app_id
    self.family_type = family_type
    self.route_prefix = route_prefix
    self.next_hoptype = next_hoptype
    self.nexthops = nexthops
    self.route_state = route_state
    self.table_name = table_name
    self.preference = preference
    self.metric = metric
    self.protocol = protocol
    self.route_flags = route_flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.app_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.family_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.route_prefix = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.next_hoptype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.nexthops = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = NexthopInfo()
            _elem33.read(iprot)
            self.nexthops.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.route_state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.preference = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = iprot.readI32();
            self.preference.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.metric = []
          (_etype43, _size40) = iprot.readListBegin()
          for _i44 in xrange(_size40):
            _elem45 = iprot.readI32();
            self.metric.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.protocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.route_flags = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RouteConfig')
    if self.app_id is not None:
      oprot.writeFieldBegin('app_id', TType.STRING, 1)
      oprot.writeString(self.app_id)
      oprot.writeFieldEnd()
    if self.family_type is not None:
      oprot.writeFieldBegin('family_type', TType.I32, 2)
      oprot.writeI32(self.family_type)
      oprot.writeFieldEnd()
    if self.route_prefix is not None:
      oprot.writeFieldBegin('route_prefix', TType.STRING, 3)
      oprot.writeString(self.route_prefix)
      oprot.writeFieldEnd()
    if self.next_hoptype is not None:
      oprot.writeFieldBegin('next_hoptype', TType.I32, 4)
      oprot.writeI32(self.next_hoptype)
      oprot.writeFieldEnd()
    if self.nexthops is not None:
      oprot.writeFieldBegin('nexthops', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.nexthops))
      for iter46 in self.nexthops:
        iter46.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.route_state is not None:
      oprot.writeFieldBegin('route_state', TType.I32, 6)
      oprot.writeI32(self.route_state)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 7)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.preference is not None:
      oprot.writeFieldBegin('preference', TType.LIST, 8)
      oprot.writeListBegin(TType.I32, len(self.preference))
      for iter47 in self.preference:
        oprot.writeI32(iter47)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metric is not None:
      oprot.writeFieldBegin('metric', TType.LIST, 9)
      oprot.writeListBegin(TType.I32, len(self.metric))
      for iter48 in self.metric:
        oprot.writeI32(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.protocol is not None:
      oprot.writeFieldBegin('protocol', TType.I32, 10)
      oprot.writeI32(self.protocol)
      oprot.writeFieldEnd()
    if self.route_flags is not None:
      oprot.writeFieldBegin('route_flags', TType.I32, 11)
      oprot.writeI32(self.route_flags)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family_type is None:
      raise TProtocol.TProtocolException(message='Required field family_type is unset!')
    if self.route_prefix is None:
      raise TProtocol.TProtocolException(message='Required field route_prefix is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
