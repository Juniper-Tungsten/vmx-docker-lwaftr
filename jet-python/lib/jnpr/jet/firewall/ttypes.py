#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class AclBooleanType:
  """
  boolean types
  """
  ACL_FALSE = 0
  ACL_TRUE = 1

  _VALUES_TO_NAMES = {
    0: "ACL_FALSE",
    1: "ACL_TRUE",
  }

  _NAMES_TO_VALUES = {
    "ACL_FALSE": 0,
    "ACL_TRUE": 1,
  }

class AclMatchOperation:
  ACL_MATCH_OP_INVALID = 0
  ACL_MATCH_OP_EQUAL = 1
  ACL_MATCH_OP_NOT_EQUAL = 2

  _VALUES_TO_NAMES = {
    0: "ACL_MATCH_OP_INVALID",
    1: "ACL_MATCH_OP_EQUAL",
    2: "ACL_MATCH_OP_NOT_EQUAL",
  }

  _NAMES_TO_VALUES = {
    "ACL_MATCH_OP_INVALID": 0,
    "ACL_MATCH_OP_EQUAL": 1,
    "ACL_MATCH_OP_NOT_EQUAL": 2,
  }

class AclPolicerType:
  """
  ACL Policer Type
  """
  ACL_POLICER_INVALID = 0
  ACL_TWO_COLOR_POLICER = 1
  ACL_THREE_COLOR_POLICER = 2
  ACL_HIERARCHICAL_POLICER = 3

  _VALUES_TO_NAMES = {
    0: "ACL_POLICER_INVALID",
    1: "ACL_TWO_COLOR_POLICER",
    2: "ACL_THREE_COLOR_POLICER",
    3: "ACL_HIERARCHICAL_POLICER",
  }

  _NAMES_TO_VALUES = {
    "ACL_POLICER_INVALID": 0,
    "ACL_TWO_COLOR_POLICER": 1,
    "ACL_THREE_COLOR_POLICER": 2,
    "ACL_HIERARCHICAL_POLICER": 3,
  }

class AclPolicerFlags:
  """
  Policer Flags
  """
  ACL_POLICER_FLAG_INVALID = 0
  ACL_POLICER_FLAG_TERM_SPECIFIC = 1
  ACL_POLICER_FLAG_FILTER_SPECIFIC = 2

  _VALUES_TO_NAMES = {
    0: "ACL_POLICER_FLAG_INVALID",
    1: "ACL_POLICER_FLAG_TERM_SPECIFIC",
    2: "ACL_POLICER_FLAG_FILTER_SPECIFIC",
  }

  _NAMES_TO_VALUES = {
    "ACL_POLICER_FLAG_INVALID": 0,
    "ACL_POLICER_FLAG_TERM_SPECIFIC": 1,
    "ACL_POLICER_FLAG_FILTER_SPECIFIC": 2,
  }

class AclPolicerRate:
  """
  Rate unit, packet size per second
  """
  ACL_POLICER_RATE_INVALID = 0
  ACL_POLICER_RATE_BPS = 1
  ACL_POLICER_RATE_KBPS = 2
  ACL_POLICER_RATE_MBPS = 3
  ACL_POLICER_RATE_GBPS = 4

  _VALUES_TO_NAMES = {
    0: "ACL_POLICER_RATE_INVALID",
    1: "ACL_POLICER_RATE_BPS",
    2: "ACL_POLICER_RATE_KBPS",
    3: "ACL_POLICER_RATE_MBPS",
    4: "ACL_POLICER_RATE_GBPS",
  }

  _NAMES_TO_VALUES = {
    "ACL_POLICER_RATE_INVALID": 0,
    "ACL_POLICER_RATE_BPS": 1,
    "ACL_POLICER_RATE_KBPS": 2,
    "ACL_POLICER_RATE_MBPS": 3,
    "ACL_POLICER_RATE_GBPS": 4,
  }

class AclPolicerBurstSize:
  ACL_POLICER_BURST_SIZE_INVALID = 0
  ACL_POLICER_BURST_SIZE_BYTE = 1
  ACL_POLICER_BURST_SIZE_KBYTE = 2
  ACL_POLICER_BURST_SIZE_MBYTE = 3
  ACL_POLICER_BURST_SIZE_GBYTE = 4

  _VALUES_TO_NAMES = {
    0: "ACL_POLICER_BURST_SIZE_INVALID",
    1: "ACL_POLICER_BURST_SIZE_BYTE",
    2: "ACL_POLICER_BURST_SIZE_KBYTE",
    3: "ACL_POLICER_BURST_SIZE_MBYTE",
    4: "ACL_POLICER_BURST_SIZE_GBYTE",
  }

  _NAMES_TO_VALUES = {
    "ACL_POLICER_BURST_SIZE_INVALID": 0,
    "ACL_POLICER_BURST_SIZE_BYTE": 1,
    "ACL_POLICER_BURST_SIZE_KBYTE": 2,
    "ACL_POLICER_BURST_SIZE_MBYTE": 3,
    "ACL_POLICER_BURST_SIZE_GBYTE": 4,
  }

class AclLossPriority:
  """
  Loss Priority
  """
  ACL_LOSS_PRIORITY_INVALID = 0
  ACL_LOSS_PRIORITY_HIGH = 1
  ACL_LOSS_PRIORITY_MEDIUM_HIGH = 2
  ACL_LOSS_PRIORITY_MEDIUM_LOW = 3
  ACL_LOSS_PRIORITY_LOW = 4

  _VALUES_TO_NAMES = {
    0: "ACL_LOSS_PRIORITY_INVALID",
    1: "ACL_LOSS_PRIORITY_HIGH",
    2: "ACL_LOSS_PRIORITY_MEDIUM_HIGH",
    3: "ACL_LOSS_PRIORITY_MEDIUM_LOW",
    4: "ACL_LOSS_PRIORITY_LOW",
  }

  _NAMES_TO_VALUES = {
    "ACL_LOSS_PRIORITY_INVALID": 0,
    "ACL_LOSS_PRIORITY_HIGH": 1,
    "ACL_LOSS_PRIORITY_MEDIUM_HIGH": 2,
    "ACL_LOSS_PRIORITY_MEDIUM_LOW": 3,
    "ACL_LOSS_PRIORITY_LOW": 4,
  }

class AclEntryActionRejectReason:
  ACL_ACTION_REJECT_REASON_INVALID = 0
  ACL_ACTION_REJECT_ADMINISTRATIVELY_PROHIBITED = 1
  ACL_ACTION_REJECT_BAD_HOST_TOS = 2
  ACL_ACTION_REJECT_BAD_NETWORK_TOS = 3
  ACL_ACTION_REJECT_FRAGMENTATION_NEEDED = 4
  ACL_ACTION_REJECT_HOST_PROHIBITED = 5
  ACL_ACTION_REJECT_HOST_UNKNOWN = 6
  ACL_ACTION_REJECT_HOST_UNREACHABLE = 7
  ACL_ACTION_REJECT_NETWORK_PROHIBITED = 8
  ACL_ACTION_REJECT_NETWORK_UNKNOWN = 9
  ACL_ACTION_REJECT_NETWORK_UNREACHABLE = 10
  ACL_ACTION_REJECT_PORT_UNREACHABLE = 11
  ACL_ACTION_REJECT_PRECEDENCE_CUTOFF = 12
  ACL_ACTION_REJECT_PRECEDENCE_VIOLATION = 13
  ACL_ACTION_REJECT_PROTOCOL_UNREACHABLE = 14
  ACL_ACTION_REJECT_SOURCE_HOST_ISOLATED = 15
  ACL_ACTION_REJECT_SOURCE_ROUTE_FAILED = 16
  ACL_ACTION_REJECT_TCP_RESET = 17

  _VALUES_TO_NAMES = {
    0: "ACL_ACTION_REJECT_REASON_INVALID",
    1: "ACL_ACTION_REJECT_ADMINISTRATIVELY_PROHIBITED",
    2: "ACL_ACTION_REJECT_BAD_HOST_TOS",
    3: "ACL_ACTION_REJECT_BAD_NETWORK_TOS",
    4: "ACL_ACTION_REJECT_FRAGMENTATION_NEEDED",
    5: "ACL_ACTION_REJECT_HOST_PROHIBITED",
    6: "ACL_ACTION_REJECT_HOST_UNKNOWN",
    7: "ACL_ACTION_REJECT_HOST_UNREACHABLE",
    8: "ACL_ACTION_REJECT_NETWORK_PROHIBITED",
    9: "ACL_ACTION_REJECT_NETWORK_UNKNOWN",
    10: "ACL_ACTION_REJECT_NETWORK_UNREACHABLE",
    11: "ACL_ACTION_REJECT_PORT_UNREACHABLE",
    12: "ACL_ACTION_REJECT_PRECEDENCE_CUTOFF",
    13: "ACL_ACTION_REJECT_PRECEDENCE_VIOLATION",
    14: "ACL_ACTION_REJECT_PROTOCOL_UNREACHABLE",
    15: "ACL_ACTION_REJECT_SOURCE_HOST_ISOLATED",
    16: "ACL_ACTION_REJECT_SOURCE_ROUTE_FAILED",
    17: "ACL_ACTION_REJECT_TCP_RESET",
  }

  _NAMES_TO_VALUES = {
    "ACL_ACTION_REJECT_REASON_INVALID": 0,
    "ACL_ACTION_REJECT_ADMINISTRATIVELY_PROHIBITED": 1,
    "ACL_ACTION_REJECT_BAD_HOST_TOS": 2,
    "ACL_ACTION_REJECT_BAD_NETWORK_TOS": 3,
    "ACL_ACTION_REJECT_FRAGMENTATION_NEEDED": 4,
    "ACL_ACTION_REJECT_HOST_PROHIBITED": 5,
    "ACL_ACTION_REJECT_HOST_UNKNOWN": 6,
    "ACL_ACTION_REJECT_HOST_UNREACHABLE": 7,
    "ACL_ACTION_REJECT_NETWORK_PROHIBITED": 8,
    "ACL_ACTION_REJECT_NETWORK_UNKNOWN": 9,
    "ACL_ACTION_REJECT_NETWORK_UNREACHABLE": 10,
    "ACL_ACTION_REJECT_PORT_UNREACHABLE": 11,
    "ACL_ACTION_REJECT_PRECEDENCE_CUTOFF": 12,
    "ACL_ACTION_REJECT_PRECEDENCE_VIOLATION": 13,
    "ACL_ACTION_REJECT_PROTOCOL_UNREACHABLE": 14,
    "ACL_ACTION_REJECT_SOURCE_HOST_ISOLATED": 15,
    "ACL_ACTION_REJECT_SOURCE_ROUTE_FAILED": 16,
    "ACL_ACTION_REJECT_TCP_RESET": 17,
  }

class AclEntryOperation:
  """
  ACL Entry operation
  """
  ACL_ENTRY_OPERATION_INVALID = 0
  ACL_ENTRY_OPERATION_ADD = 1
  ACL_ENTRY_OPERATION_DELETE = 2
  ACL_ENTRY_OPERATION_REPLACE = 3

  _VALUES_TO_NAMES = {
    0: "ACL_ENTRY_OPERATION_INVALID",
    1: "ACL_ENTRY_OPERATION_ADD",
    2: "ACL_ENTRY_OPERATION_DELETE",
    3: "ACL_ENTRY_OPERATION_REPLACE",
  }

  _NAMES_TO_VALUES = {
    "ACL_ENTRY_OPERATION_INVALID": 0,
    "ACL_ENTRY_OPERATION_ADD": 1,
    "ACL_ENTRY_OPERATION_DELETE": 2,
    "ACL_ENTRY_OPERATION_REPLACE": 3,
  }

class AclAdjacencyType:
  """
  Adjacency Type
  """
  ACL_ADJACENCY_NONE = 0
  ACL_ADJACENCY_AFTER = 1
  ACL_ADJACENCY_BEFORE = 2

  _VALUES_TO_NAMES = {
    0: "ACL_ADJACENCY_NONE",
    1: "ACL_ADJACENCY_AFTER",
    2: "ACL_ADJACENCY_BEFORE",
  }

  _NAMES_TO_VALUES = {
    "ACL_ADJACENCY_NONE": 0,
    "ACL_ADJACENCY_AFTER": 1,
    "ACL_ADJACENCY_BEFORE": 2,
  }

class AclFragmentFlags:
  """
  Fragment Flags
  """
  ACL_FRAGMENT_NONE = 0
  ACL_DONT_FRAGMENT = 1
  ACL_IS_FRAGMENT = 2
  ACL_FIRST_FRAGMENT = 3
  ACL_LAST_FRAGMENT = 4

  _VALUES_TO_NAMES = {
    0: "ACL_FRAGMENT_NONE",
    1: "ACL_DONT_FRAGMENT",
    2: "ACL_IS_FRAGMENT",
    3: "ACL_FIRST_FRAGMENT",
    4: "ACL_LAST_FRAGMENT",
  }

  _NAMES_TO_VALUES = {
    "ACL_FRAGMENT_NONE": 0,
    "ACL_DONT_FRAGMENT": 1,
    "ACL_IS_FRAGMENT": 2,
    "ACL_FIRST_FRAGMENT": 3,
    "ACL_LAST_FRAGMENT": 4,
  }

class Precedence:
  """
  Precedence
  """
  ACL_PRECEDENCE_ROUTINE = 0
  ACL_PRECEDENCE_PRIORITY = 1
  ACL_PRECEDENCE_IMMEDIATE = 2
  ACL_PRECEDENCE_FLASH = 3
  ACL_PRECEDENCE_FLASH_OVERRIDE = 4
  ACL_PRECEDENCE_CRITICAL_ECP = 5
  ACL_PRECEDENCE_INTERNET_CONTROL = 6
  ACL_PRECEDENCE_NET_CONTROL = 7

  _VALUES_TO_NAMES = {
    0: "ACL_PRECEDENCE_ROUTINE",
    1: "ACL_PRECEDENCE_PRIORITY",
    2: "ACL_PRECEDENCE_IMMEDIATE",
    3: "ACL_PRECEDENCE_FLASH",
    4: "ACL_PRECEDENCE_FLASH_OVERRIDE",
    5: "ACL_PRECEDENCE_CRITICAL_ECP",
    6: "ACL_PRECEDENCE_INTERNET_CONTROL",
    7: "ACL_PRECEDENCE_NET_CONTROL",
  }

  _NAMES_TO_VALUES = {
    "ACL_PRECEDENCE_ROUTINE": 0,
    "ACL_PRECEDENCE_PRIORITY": 1,
    "ACL_PRECEDENCE_IMMEDIATE": 2,
    "ACL_PRECEDENCE_FLASH": 3,
    "ACL_PRECEDENCE_FLASH_OVERRIDE": 4,
    "ACL_PRECEDENCE_CRITICAL_ECP": 5,
    "ACL_PRECEDENCE_INTERNET_CONTROL": 6,
    "ACL_PRECEDENCE_NET_CONTROL": 7,
  }

class AccessListFamilies:
  """
  AccessList Families.
  Currently only inet family firewall ACLs are supported.
  """
  ACL_FAMILY_INVALID = 0
  ACL_FAMILY_INET = 1

  _VALUES_TO_NAMES = {
    0: "ACL_FAMILY_INVALID",
    1: "ACL_FAMILY_INET",
  }

  _NAMES_TO_VALUES = {
    "ACL_FAMILY_INVALID": 0,
    "ACL_FAMILY_INET": 1,
  }

class AccessListFlags:
  """
  AccessListFlags
  Any proprietory flag to be enabled at the ACL level.
  """
  ACL_FLAGS_NONE = 0

  _VALUES_TO_NAMES = {
    0: "ACL_FLAGS_NONE",
  }

  _NAMES_TO_VALUES = {
    "ACL_FLAGS_NONE": 0,
  }

class AccessListTypes:
  """
  AccessList types.
  Currently only classic is supported.
  """
  ACL_TYPE_INVALID = 0
  ACL_TYPE_CLASSIC = 1

  _VALUES_TO_NAMES = {
    0: "ACL_TYPE_INVALID",
    1: "ACL_TYPE_CLASSIC",
  }

  _NAMES_TO_VALUES = {
    "ACL_TYPE_INVALID": 0,
    "ACL_TYPE_CLASSIC": 1,
  }

class AclBindDirection:
  """
  AccessList Bind Direction
  """
  ACL_BIND_DIRECTION_INVALID = 0
  ACL_BIND_DIRECTION_INPUT = 1
  ACL_BIND_DIRECTION_OUTPUT = 2

  _VALUES_TO_NAMES = {
    0: "ACL_BIND_DIRECTION_INVALID",
    1: "ACL_BIND_DIRECTION_INPUT",
    2: "ACL_BIND_DIRECTION_OUTPUT",
  }

  _NAMES_TO_VALUES = {
    "ACL_BIND_DIRECTION_INVALID": 0,
    "ACL_BIND_DIRECTION_INPUT": 1,
    "ACL_BIND_DIRECTION_OUTPUT": 2,
  }

class AccessListReturnVal:
  ACL_STATUS_INVALID = 0
  ACL_STATUS_EOK = 1
  ACL_STATUS_NULL_MESSAGE = 2
  ACL_STATUS_EINVALID_MESSAGE = 3
  ACL_STATUS_EINTERNAL = 4
  ACL_STATUS_EUNSUPPORTED_OP = 5
  ACL_STATUS_NO_RESOURCE = 7
  ACL_STATUS_BS_TIMEOUT = 8

  _VALUES_TO_NAMES = {
    0: "ACL_STATUS_INVALID",
    1: "ACL_STATUS_EOK",
    2: "ACL_STATUS_NULL_MESSAGE",
    3: "ACL_STATUS_EINVALID_MESSAGE",
    4: "ACL_STATUS_EINTERNAL",
    5: "ACL_STATUS_EUNSUPPORTED_OP",
    7: "ACL_STATUS_NO_RESOURCE",
    8: "ACL_STATUS_BS_TIMEOUT",
  }

  _NAMES_TO_VALUES = {
    "ACL_STATUS_INVALID": 0,
    "ACL_STATUS_EOK": 1,
    "ACL_STATUS_NULL_MESSAGE": 2,
    "ACL_STATUS_EINVALID_MESSAGE": 3,
    "ACL_STATUS_EINTERNAL": 4,
    "ACL_STATUS_EUNSUPPORTED_OP": 5,
    "ACL_STATUS_NO_RESOURCE": 7,
    "ACL_STATUS_BS_TIMEOUT": 8,
  }

class AccessListBindObjType:
  ACL_BIND_OBJ_TYPE_INVALID = 0
  ACL_BIND_OBJ_TYPE_INTERFACE = 1

  _VALUES_TO_NAMES = {
    0: "ACL_BIND_OBJ_TYPE_INVALID",
    1: "ACL_BIND_OBJ_TYPE_INTERFACE",
  }

  _NAMES_TO_VALUES = {
    "ACL_BIND_OBJ_TYPE_INVALID": 0,
    "ACL_BIND_OBJ_TYPE_INTERFACE": 1,
  }


class AclPolicerTwoColor:
  """
  Policer parameter for 2 color policer

  Attributes:
   - bw_unit: Bandwidth unit
   - bandwidth: Bandwidth rate
   - burst_unit: Burst unit
   - burst_size: Burst size
   - lp: Loss priority
   - fc_string: Forwarding class should be provided as a string
   - discard: Discard action
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'bw_unit', None, None, ), # 1
    (2, TType.I64, 'bandwidth', None, None, ), # 2
    (3, TType.I32, 'burst_unit', None, None, ), # 3
    (4, TType.I64, 'burst_size', None, None, ), # 4
    (5, TType.I32, 'lp', None, None, ), # 5
    (6, TType.STRING, 'fc_string', None, None, ), # 6
    (7, TType.I32, 'discard', None, None, ), # 7
  )

  def __init__(self, bw_unit=None, bandwidth=None, burst_unit=None, burst_size=None, lp=None, fc_string=None, discard=None,):
    self.bw_unit = bw_unit
    self.bandwidth = bandwidth
    self.burst_unit = burst_unit
    self.burst_size = burst_size
    self.lp = lp
    self.fc_string = fc_string
    self.discard = discard

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.bw_unit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.bandwidth = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.burst_unit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.burst_size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.lp = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.fc_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.discard = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclPolicerTwoColor')
    if self.bw_unit is not None:
      oprot.writeFieldBegin('bw_unit', TType.I32, 1)
      oprot.writeI32(self.bw_unit)
      oprot.writeFieldEnd()
    if self.bandwidth is not None:
      oprot.writeFieldBegin('bandwidth', TType.I64, 2)
      oprot.writeI64(self.bandwidth)
      oprot.writeFieldEnd()
    if self.burst_unit is not None:
      oprot.writeFieldBegin('burst_unit', TType.I32, 3)
      oprot.writeI32(self.burst_unit)
      oprot.writeFieldEnd()
    if self.burst_size is not None:
      oprot.writeFieldBegin('burst_size', TType.I64, 4)
      oprot.writeI64(self.burst_size)
      oprot.writeFieldEnd()
    if self.lp is not None:
      oprot.writeFieldBegin('lp', TType.I32, 5)
      oprot.writeI32(self.lp)
      oprot.writeFieldEnd()
    if self.fc_string is not None:
      oprot.writeFieldBegin('fc_string', TType.STRING, 6)
      oprot.writeString(self.fc_string)
      oprot.writeFieldEnd()
    if self.discard is not None:
      oprot.writeFieldBegin('discard', TType.I32, 7)
      oprot.writeI32(self.discard)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclPolicerParameter:
  """
  ACL Policer parameter

  Attributes:
   - two_color_parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'two_color_parameter', (AclPolicerTwoColor, AclPolicerTwoColor.thrift_spec), None, ), # 1
  )

  def __init__(self, two_color_parameter=None,):
    self.two_color_parameter = two_color_parameter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.two_color_parameter = AclPolicerTwoColor()
          self.two_color_parameter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclPolicerParameter')
    if self.two_color_parameter is not None:
      oprot.writeFieldBegin('two_color_parameter', TType.STRUCT, 1)
      self.two_color_parameter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicer:
  """
  A Policer

  Attributes:
   - policer_name: Policer name (Less than 64 characters).
  Requiredness: required.
   - policer_type: Policer type
   - policer_flag: Policer Flags
   - policer_params: Policer Paremeter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'policer_name', None, None, ), # 1
    (2, TType.I32, 'policer_type', None, None, ), # 2
    (3, TType.I32, 'policer_flag', None, None, ), # 3
    (4, TType.STRUCT, 'policer_params', (AclPolicerParameter, AclPolicerParameter.thrift_spec), None, ), # 4
  )

  def __init__(self, policer_name=None, policer_type=None, policer_flag=None, policer_params=None,):
    self.policer_name = policer_name
    self.policer_type = policer_type
    self.policer_flag = policer_flag
    self.policer_params = policer_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.policer_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.policer_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.policer_flag = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.policer_params = AclPolicerParameter()
          self.policer_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicer')
    if self.policer_name is not None:
      oprot.writeFieldBegin('policer_name', TType.STRING, 1)
      oprot.writeString(self.policer_name)
      oprot.writeFieldEnd()
    if self.policer_type is not None:
      oprot.writeFieldBegin('policer_type', TType.I32, 2)
      oprot.writeI32(self.policer_type)
      oprot.writeFieldEnd()
    if self.policer_flag is not None:
      oprot.writeFieldBegin('policer_flag', TType.I32, 3)
      oprot.writeI32(self.policer_flag)
      oprot.writeFieldEnd()
    if self.policer_params is not None:
      oprot.writeFieldBegin('policer_params', TType.STRUCT, 4)
      self.policer_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IpAddress:
  """
  Attributes:
   - addr_string
   - addr_bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'addr_string', None, None, ), # 1
    (2, TType.STRING, 'addr_bytes', None, None, ), # 2
  )

  def __init__(self, addr_string=None, addr_bytes=None,):
    self.addr_string = addr_string
    self.addr_bytes = addr_bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.addr_string = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.addr_bytes = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IpAddress')
    if self.addr_string is not None:
      oprot.writeFieldBegin('addr_string', TType.STRING, 1)
      oprot.writeString(self.addr_string)
      oprot.writeFieldEnd()
    if self.addr_bytes is not None:
      oprot.writeFieldBegin('addr_bytes', TType.STRING, 2)
      oprot.writeString(self.addr_bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchIpAddress:
  """
  Address match condition

  Attributes:
   - addr: Destination address
   - prefix_len: Destination prefix length
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'addr', (IpAddress, IpAddress.thrift_spec), None, ), # 1
    (2, TType.I32, 'prefix_len', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, addr=None, prefix_len=None, match_op=None,):
    self.addr = addr
    self.prefix_len = prefix_len
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.addr = IpAddress()
          self.addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.prefix_len = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchIpAddress')
    if self.addr is not None:
      oprot.writeFieldBegin('addr', TType.STRUCT, 1)
      self.addr.write(oprot)
      oprot.writeFieldEnd()
    if self.prefix_len is not None:
      oprot.writeFieldBegin('prefix_len', TType.I32, 2)
      oprot.writeI32(self.prefix_len)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchPort:
  """
  Matching Port match condition

  Attributes:
   - min: Minimum destination port
   - max: Maximum destination port
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchPort')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchDscpCode:
  """
  DSCP (diffserv code point) match condition

  Attributes:
   - min: Minimum Dscp code
   - max: Maximum Dscp code
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchDscpCode')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchProtocol:
  """
  IP Protocol match condition

  Attributes:
   - min: Minimum Protocol number
   - max: Maximum Protocol number
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchProtocol')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchIcmpType:
  """
  ICMP type match condition

  Attributes:
   - min: Minimum Icmp type
   - max: Maximum Icmp type
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchIcmpType')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchIcmpCode:
  """
  ICMP code match condition

  Attributes:
   - min: Minimum Icmp code
   - max: Maximum Icmp code
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchIcmpCode')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchPktLen:
  """
  Packet length match condition

  Attributes:
   - min: Minimum Packet length
   - max: Maximum Packet length
   - match_op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchPktLen')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchTtl:
  """
  TTL (Time to live) match condition for IPv4

  Attributes:
   - min: Minimum Time to live
   - max: Maximum Time to live
   - match_op: AclMatch op
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'min', None, None, ), # 1
    (2, TType.I32, 'max', None, None, ), # 2
    (3, TType.I32, 'match_op', None, None, ), # 3
  )

  def __init__(self, min=None, max=None, match_op=None,):
    self.min = min
    self.max = max
    self.match_op = match_op

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchTtl')
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    if self.match_op is not None:
      oprot.writeFieldBegin('match_op', TType.I32, 3)
      oprot.writeI32(self.match_op)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclActionPolicer:
  """
  Police the matching packets

  Attributes:
   - policer: The policer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'policer', (AccessListPolicer, AccessListPolicer.thrift_spec), None, ), # 1
  )

  def __init__(self, policer=None,):
    self.policer = policer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.policer = AccessListPolicer()
          self.policer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclActionPolicer')
    if self.policer is not None:
      oprot.writeFieldBegin('policer', TType.STRUCT, 1)
      self.policer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclActionCounter:
  """
  Count the matching packets

  Attributes:
   - counter_name: Counter name (upto 64 characters)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'counter_name', None, None, ), # 1
  )

  def __init__(self, counter_name=None,):
    self.counter_name = counter_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclActionCounter')
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 1)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclActionRoutingInstance:
  """
  Direct matching packets to a routing-instance

  Attributes:
   - rt_instance_name: Policer name (upto 64 characters)
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'rt_instance_name', None, None, ), # 1
  )

  def __init__(self, rt_instance_name=None,):
    self.rt_instance_name = rt_instance_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.rt_instance_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclActionRoutingInstance')
    if self.rt_instance_name is not None:
      oprot.writeFieldBegin('rt_instance_name', TType.STRING, 1)
      oprot.writeString(self.rt_instance_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclAdjacency:
  """
  Adjacency details of ace placement

  Attributes:
   - type: Type of adjacency placement
   - ace_name: Type of adjacency placement
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'ace_name', None, None, ), # 2
  )

  def __init__(self, type=None, ace_name=None,):
    self.type = type
    self.ace_name = ace_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ace_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclAdjacency')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.ace_name is not None:
      oprot.writeFieldBegin('ace_name', TType.STRING, 2)
      oprot.writeString(self.ace_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclMatchIflNameIndex:
  """
  Attributes:
   - ifl_name: IFL name
   - ifl_index: IFL index
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ifl_name', None, None, ), # 1
    (2, TType.I32, 'ifl_index', None, None, ), # 2
  )

  def __init__(self, ifl_name=None, ifl_index=None,):
    self.ifl_name = ifl_name
    self.ifl_index = ifl_index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ifl_index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclMatchIflNameIndex')
    if self.ifl_name is not None:
      oprot.writeFieldBegin('ifl_name', TType.STRING, 1)
      oprot.writeString(self.ifl_name)
      oprot.writeFieldEnd()
    if self.ifl_index is not None:
      oprot.writeFieldBegin('ifl_index', TType.I32, 2)
      oprot.writeI32(self.ifl_index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclEntryMatchInet:
  """
  An ACL Match

  Attributes:
   - match_dst_addrs: List of Destination addresses
   - match_src_addrs: List of Source addresses
   - match_dst_ports: List of Destination ports
   - match_src_ports: List of Source ports
   - match_dscp_code: List of Dscp code points
   - match_protocols: List of Protocols
   - match_icmp_type: List of Icmp types
   - match_icmp_code: List of Icmp codes
   - match_pkt_len: List of Packet lengths
   - match_ttl: List of Ttl's
   - fragment_flags: Fragment type
   - ifl_names: Interface name (IFL with unit e.g. ge-0/0/1.0)
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'match_dst_addrs', (TType.STRUCT,(AclMatchIpAddress, AclMatchIpAddress.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'match_src_addrs', (TType.STRUCT,(AclMatchIpAddress, AclMatchIpAddress.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'match_dst_ports', (TType.STRUCT,(AclMatchPort, AclMatchPort.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'match_src_ports', (TType.STRUCT,(AclMatchPort, AclMatchPort.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'match_dscp_code', (TType.STRUCT,(AclMatchDscpCode, AclMatchDscpCode.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'match_protocols', (TType.STRUCT,(AclMatchProtocol, AclMatchProtocol.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'match_icmp_type', (TType.STRUCT,(AclMatchIcmpType, AclMatchIcmpType.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'match_icmp_code', (TType.STRUCT,(AclMatchIcmpCode, AclMatchIcmpCode.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'match_pkt_len', (TType.STRUCT,(AclMatchPktLen, AclMatchPktLen.thrift_spec)), None, ), # 9
    (10, TType.LIST, 'match_ttl', (TType.STRUCT,(AclMatchTtl, AclMatchTtl.thrift_spec)), None, ), # 10
    (11, TType.I32, 'fragment_flags', None, None, ), # 11
    None, # 12
    (13, TType.STRUCT, 'ifl_names', (AclMatchIflNameIndex, AclMatchIflNameIndex.thrift_spec), None, ), # 13
  )

  def __init__(self, match_dst_addrs=None, match_src_addrs=None, match_dst_ports=None, match_src_ports=None, match_dscp_code=None, match_protocols=None, match_icmp_type=None, match_icmp_code=None, match_pkt_len=None, match_ttl=None, fragment_flags=None, ifl_names=None,):
    self.match_dst_addrs = match_dst_addrs
    self.match_src_addrs = match_src_addrs
    self.match_dst_ports = match_dst_ports
    self.match_src_ports = match_src_ports
    self.match_dscp_code = match_dscp_code
    self.match_protocols = match_protocols
    self.match_icmp_type = match_icmp_type
    self.match_icmp_code = match_icmp_code
    self.match_pkt_len = match_pkt_len
    self.match_ttl = match_ttl
    self.fragment_flags = fragment_flags
    self.ifl_names = ifl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.match_dst_addrs = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = AclMatchIpAddress()
            _elem5.read(iprot)
            self.match_dst_addrs.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.match_src_addrs = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = AclMatchIpAddress()
            _elem11.read(iprot)
            self.match_src_addrs.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.match_dst_ports = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = AclMatchPort()
            _elem17.read(iprot)
            self.match_dst_ports.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.match_src_ports = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = AclMatchPort()
            _elem23.read(iprot)
            self.match_src_ports.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.match_dscp_code = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = AclMatchDscpCode()
            _elem29.read(iprot)
            self.match_dscp_code.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.match_protocols = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = AclMatchProtocol()
            _elem35.read(iprot)
            self.match_protocols.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.match_icmp_type = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = AclMatchIcmpType()
            _elem41.read(iprot)
            self.match_icmp_type.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.match_icmp_code = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = AclMatchIcmpCode()
            _elem47.read(iprot)
            self.match_icmp_code.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.match_pkt_len = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = AclMatchPktLen()
            _elem53.read(iprot)
            self.match_pkt_len.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.match_ttl = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = AclMatchTtl()
            _elem59.read(iprot)
            self.match_ttl.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.fragment_flags = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.ifl_names = AclMatchIflNameIndex()
          self.ifl_names.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclEntryMatchInet')
    if self.match_dst_addrs is not None:
      oprot.writeFieldBegin('match_dst_addrs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.match_dst_addrs))
      for iter60 in self.match_dst_addrs:
        iter60.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_src_addrs is not None:
      oprot.writeFieldBegin('match_src_addrs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.match_src_addrs))
      for iter61 in self.match_src_addrs:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_dst_ports is not None:
      oprot.writeFieldBegin('match_dst_ports', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.match_dst_ports))
      for iter62 in self.match_dst_ports:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_src_ports is not None:
      oprot.writeFieldBegin('match_src_ports', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.match_src_ports))
      for iter63 in self.match_src_ports:
        iter63.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_dscp_code is not None:
      oprot.writeFieldBegin('match_dscp_code', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.match_dscp_code))
      for iter64 in self.match_dscp_code:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_protocols is not None:
      oprot.writeFieldBegin('match_protocols', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.match_protocols))
      for iter65 in self.match_protocols:
        iter65.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_icmp_type is not None:
      oprot.writeFieldBegin('match_icmp_type', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.match_icmp_type))
      for iter66 in self.match_icmp_type:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_icmp_code is not None:
      oprot.writeFieldBegin('match_icmp_code', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.match_icmp_code))
      for iter67 in self.match_icmp_code:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_pkt_len is not None:
      oprot.writeFieldBegin('match_pkt_len', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.match_pkt_len))
      for iter68 in self.match_pkt_len:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_ttl is not None:
      oprot.writeFieldBegin('match_ttl', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.match_ttl))
      for iter69 in self.match_ttl:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fragment_flags is not None:
      oprot.writeFieldBegin('fragment_flags', TType.I32, 11)
      oprot.writeI32(self.fragment_flags)
      oprot.writeFieldEnd()
    if self.ifl_names is not None:
      oprot.writeFieldBegin('ifl_names', TType.STRUCT, 13)
      self.ifl_names.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclEntryInetTerminatingAction:
  """
  A terminating ACL Action

  Attributes:
   - action_accept: Accept the matching packets
   - action_discard: Discard the matching packets
   - action_reject: Reject the matching packets
   - action_rt_inst: Direct matching packets to a routing instance
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_accept', None, None, ), # 1
    (2, TType.I32, 'action_discard', None, None, ), # 2
    (3, TType.I32, 'action_reject', None, None, ), # 3
    (4, TType.STRUCT, 'action_rt_inst', (AclActionRoutingInstance, AclActionRoutingInstance.thrift_spec), None, ), # 4
  )

  def __init__(self, action_accept=None, action_discard=None, action_reject=None, action_rt_inst=None,):
    self.action_accept = action_accept
    self.action_discard = action_discard
    self.action_reject = action_reject
    self.action_rt_inst = action_rt_inst

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_accept = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_discard = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_reject = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_rt_inst = AclActionRoutingInstance()
          self.action_rt_inst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclEntryInetTerminatingAction')
    if self.action_accept is not None:
      oprot.writeFieldBegin('action_accept', TType.I32, 1)
      oprot.writeI32(self.action_accept)
      oprot.writeFieldEnd()
    if self.action_discard is not None:
      oprot.writeFieldBegin('action_discard', TType.I32, 2)
      oprot.writeI32(self.action_discard)
      oprot.writeFieldEnd()
    if self.action_reject is not None:
      oprot.writeFieldBegin('action_reject', TType.I32, 3)
      oprot.writeI32(self.action_reject)
      oprot.writeFieldEnd()
    if self.action_rt_inst is not None:
      oprot.writeFieldBegin('action_rt_inst', TType.STRUCT, 4)
      self.action_rt_inst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclEntryInetNonTerminatingAction:
  """
  An ACL NonTerminating Action

  Attributes:
   - action_count: Count the matching packets
   - action_log: Log the matching packets
   - action_syslog: Syslog the matching packets
   - action_police: Police the matching packets.
  Ensure that policer exists before it being used.
   - action_sample: Sample
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'action_count', (AclActionCounter, AclActionCounter.thrift_spec), None, ), # 1
    (2, TType.I32, 'action_log', None, None, ), # 2
    (3, TType.I32, 'action_syslog', None, None, ), # 3
    (4, TType.STRUCT, 'action_police', (AclActionPolicer, AclActionPolicer.thrift_spec), None, ), # 4
    (5, TType.I32, 'action_sample', None, None, ), # 5
  )

  def __init__(self, action_count=None, action_log=None, action_syslog=None, action_police=None, action_sample=None,):
    self.action_count = action_count
    self.action_log = action_log
    self.action_syslog = action_syslog
    self.action_police = action_police
    self.action_sample = action_sample

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.action_count = AclActionCounter()
          self.action_count.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_log = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_syslog = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.action_police = AclActionPolicer()
          self.action_police.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_sample = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclEntryInetNonTerminatingAction')
    if self.action_count is not None:
      oprot.writeFieldBegin('action_count', TType.STRUCT, 1)
      self.action_count.write(oprot)
      oprot.writeFieldEnd()
    if self.action_log is not None:
      oprot.writeFieldBegin('action_log', TType.I32, 2)
      oprot.writeI32(self.action_log)
      oprot.writeFieldEnd()
    if self.action_syslog is not None:
      oprot.writeFieldBegin('action_syslog', TType.I32, 3)
      oprot.writeI32(self.action_syslog)
      oprot.writeFieldEnd()
    if self.action_police is not None:
      oprot.writeFieldBegin('action_police', TType.STRUCT, 4)
      self.action_police.write(oprot)
      oprot.writeFieldEnd()
    if self.action_sample is not None:
      oprot.writeFieldBegin('action_sample', TType.I32, 5)
      oprot.writeI32(self.action_sample)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclEntryInetAction:
  """
  An ACL Action

  Attributes:
   - actions_nt: non-terminating actions.
   - action_t: One terminating action
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actions_nt', (AclEntryInetNonTerminatingAction, AclEntryInetNonTerminatingAction.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'action_t', (AclEntryInetTerminatingAction, AclEntryInetTerminatingAction.thrift_spec), None, ), # 2
  )

  def __init__(self, actions_nt=None, action_t=None,):
    self.actions_nt = actions_nt
    self.action_t = action_t

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actions_nt = AclEntryInetNonTerminatingAction()
          self.actions_nt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.action_t = AclEntryInetTerminatingAction()
          self.action_t.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclEntryInetAction')
    if self.actions_nt is not None:
      oprot.writeFieldBegin('actions_nt', TType.STRUCT, 1)
      self.actions_nt.write(oprot)
      oprot.writeFieldEnd()
    if self.action_t is not None:
      oprot.writeFieldBegin('action_t', TType.STRUCT, 2)
      self.action_t.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclInetEntry:
  """
  An Inet ACL entry

  Attributes:
   - ace_name: AclEntry name (Less than 64 characters)
   - ace_op: AclEntry operation
   - adjacency: Adjacency
   - matches: Matches
   - actions: Actions
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ace_name', None, None, ), # 1
    (2, TType.I32, 'ace_op', None, None, ), # 2
    (3, TType.STRUCT, 'adjacency', (AclAdjacency, AclAdjacency.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'matches', (AclEntryMatchInet, AclEntryMatchInet.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'actions', (AclEntryInetAction, AclEntryInetAction.thrift_spec), None, ), # 5
  )

  def __init__(self, ace_name=None, ace_op=None, adjacency=None, matches=None, actions=None,):
    self.ace_name = ace_name
    self.ace_op = ace_op
    self.adjacency = adjacency
    self.matches = matches
    self.actions = actions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ace_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ace_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.adjacency = AclAdjacency()
          self.adjacency.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.matches = AclEntryMatchInet()
          self.matches.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.actions = AclEntryInetAction()
          self.actions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclInetEntry')
    if self.ace_name is not None:
      oprot.writeFieldBegin('ace_name', TType.STRING, 1)
      oprot.writeString(self.ace_name)
      oprot.writeFieldEnd()
    if self.ace_op is not None:
      oprot.writeFieldBegin('ace_op', TType.I32, 2)
      oprot.writeI32(self.ace_op)
      oprot.writeFieldEnd()
    if self.adjacency is not None:
      oprot.writeFieldBegin('adjacency', TType.STRUCT, 3)
      self.adjacency.write(oprot)
      oprot.writeFieldEnd()
    if self.matches is not None:
      oprot.writeFieldBegin('matches', TType.STRUCT, 4)
      self.matches.write(oprot)
      oprot.writeFieldEnd()
    if self.actions is not None:
      oprot.writeFieldBegin('actions', TType.STRUCT, 5)
      self.actions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AclEntry:
  """
  An ACL entry. It could be one of type of families.

  Attributes:
   - inet_entry: For Inet family
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'inet_entry', (AclInetEntry, AclInetEntry.thrift_spec), None, ), # 1
  )

  def __init__(self, inet_entry=None,):
    self.inet_entry = inet_entry

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.inet_entry = AclInetEntry()
          self.inet_entry.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AclEntry')
    if self.inet_entry is not None:
      oprot.writeFieldBegin('inet_entry', TType.STRUCT, 1)
      self.inet_entry.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessList:
  """
  An ACL

  Attributes:
   - acl_name: AccessList name (Less than 64 characters)
   - acl_type: AccessList type
   - acl_family: AccessList family
   - acl_flag: AccessList flag
   - ace_list: List of Destination addresses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'acl_name', None, None, ), # 1
    (2, TType.I32, 'acl_type', None, None, ), # 2
    (3, TType.I32, 'acl_family', None, None, ), # 3
    (4, TType.I32, 'acl_flag', None, None, ), # 4
    (5, TType.LIST, 'ace_list', (TType.STRUCT,(AclEntry, AclEntry.thrift_spec)), None, ), # 5
  )

  def __init__(self, acl_name=None, acl_type=None, acl_family=None, acl_flag=None, ace_list=None,):
    self.acl_name = acl_name
    self.acl_type = acl_type
    self.acl_family = acl_family
    self.acl_flag = acl_flag
    self.ace_list = ace_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.acl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.acl_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.acl_family = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.acl_flag = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.ace_list = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = AclEntry()
            _elem75.read(iprot)
            self.ace_list.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessList')
    if self.acl_name is not None:
      oprot.writeFieldBegin('acl_name', TType.STRING, 1)
      oprot.writeString(self.acl_name)
      oprot.writeFieldEnd()
    if self.acl_type is not None:
      oprot.writeFieldBegin('acl_type', TType.I32, 2)
      oprot.writeI32(self.acl_type)
      oprot.writeFieldEnd()
    if self.acl_family is not None:
      oprot.writeFieldBegin('acl_family', TType.I32, 3)
      oprot.writeI32(self.acl_family)
      oprot.writeFieldEnd()
    if self.acl_flag is not None:
      oprot.writeFieldBegin('acl_flag', TType.I32, 4)
      oprot.writeI32(self.acl_flag)
      oprot.writeFieldEnd()
    if self.ace_list is not None:
      oprot.writeFieldBegin('ace_list', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.ace_list))
      for iter76 in self.ace_list:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounter:
  """
  Attributes:
   - acl: Access list
   - counter_name: Counter name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl', (AccessList, AccessList.thrift_spec), None, ), # 1
    (2, TType.STRING, 'counter_name', None, None, ), # 2
  )

  def __init__(self, acl=None, counter_name=None,):
    self.acl = acl
    self.counter_name = counter_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl = AccessList()
          self.acl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounter')
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.STRUCT, 1)
      self.acl.write(oprot)
      oprot.writeFieldEnd()
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 2)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounterVal:
  """
  Attributes:
   - counter_name: Counter Name
   - status: Error status
   - bytes: Byte count
   - packets: Packet count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'counter_name', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.I64, 'bytes', None, None, ), # 3
    (4, TType.I64, 'packets', None, None, ), # 4
  )

  def __init__(self, counter_name=None, status=None, bytes=None, packets=None,):
    self.counter_name = counter_name
    self.status = status
    self.bytes = bytes
    self.packets = packets

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.counter_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.packets = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounterVal')
    if self.counter_name is not None:
      oprot.writeFieldBegin('counter_name', TType.STRING, 1)
      oprot.writeString(self.counter_name)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 3)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    if self.packets is not None:
      oprot.writeFieldBegin('packets', TType.I64, 4)
      oprot.writeI64(self.packets)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListObjBind:
  """
  Per forwarding element ACL bindings

  Attributes:
   - acl: Access list
   - obj_type: Access list object type
   - bind_object: Bind object name where the ACL is to be bound
   - bind_direction: Bind direction
   - bind_family: Family on the bind object. Must match with the ACL family
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl', (AccessList, AccessList.thrift_spec), None, ), # 1
    (2, TType.I32, 'obj_type', None, None, ), # 2
    (3, TType.STRING, 'bind_object', None, None, ), # 3
    (4, TType.I32, 'bind_direction', None, None, ), # 4
    (5, TType.I32, 'bind_family', None, None, ), # 5
  )

  def __init__(self, acl=None, obj_type=None, bind_object=None, bind_direction=None, bind_family=None,):
    self.acl = acl
    self.obj_type = obj_type
    self.bind_object = bind_object
    self.bind_direction = bind_direction
    self.bind_family = bind_family

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl = AccessList()
          self.acl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.obj_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bind_object = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.bind_direction = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.bind_family = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListObjBind')
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.STRUCT, 1)
      self.acl.write(oprot)
      oprot.writeFieldEnd()
    if self.obj_type is not None:
      oprot.writeFieldBegin('obj_type', TType.I32, 2)
      oprot.writeI32(self.obj_type)
      oprot.writeFieldEnd()
    if self.bind_object is not None:
      oprot.writeFieldBegin('bind_object', TType.STRING, 3)
      oprot.writeString(self.bind_object)
      oprot.writeFieldEnd()
    if self.bind_direction is not None:
      oprot.writeFieldBegin('bind_direction', TType.I32, 4)
      oprot.writeI32(self.bind_direction)
      oprot.writeFieldEnd()
    if self.bind_family is not None:
      oprot.writeFieldBegin('bind_family', TType.I32, 5)
      oprot.writeI32(self.bind_family)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListReturnStatus:
  """
  Attributes:
   - status
   - err_str
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.STRING, 'err_str', None, None, ), # 2
  )

  def __init__(self, status=None, err_str=None,):
    self.status = status
    self.err_str = err_str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.err_str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListReturnStatus')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.err_str is not None:
      oprot.writeFieldBegin('err_str', TType.STRING, 2)
      oprot.writeString(self.err_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
