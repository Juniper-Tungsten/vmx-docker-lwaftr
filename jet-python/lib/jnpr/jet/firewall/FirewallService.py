#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  Firewall Service APIs
  """
  def AccessListAdd(self, acl):
    """
    Adds an ACL and returns the result.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    pass

  def AccessListDelete(self, acl):
    """
    Delete an ACL from the system and return the result.
    For successful delete to happen, the ACL should not be bound to any object.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    pass

  def AccessListChange(self, acl):
    """
    Changes an ACL based on the list of ACL entries provided, and returns the result.
    It is advisable to use this API to for small incremental changes. For wholesale
    changes, it is recommended to use the 'Replace' version of the API.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    pass

  def AccessListBindAdd(self, bind_obj):
    """
    Add a binding of an ACL with a bind object and return the result.

    Parameters:
     - bind_obj: Bind object
    """
    pass

  def AccessListBindDelete(self, bind_obj):
    """
    Deletes a binding of an ACL with a bind object and return the result.

    Parameters:
     - bind_obj: Bind object
    """
    pass

  def AccessListPolicerAdd(self, policer):
    """
    Adds a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    pass

  def AccessListPolicerReplace(self, policer):
    """
    Changes a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    pass

  def AccessListPolicerDelete(self, policer):
    """
    Deletes a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    pass

  def AccessListCounterGet(self, acl_counter):
    """
    Few points to note with this API.
    The call is going to be blocking for worst case of 10 seconds which is non configurable.
    The counter name is expected to be fully resolved. For eg. for term specific policer counter
    it is expected to be passed to full counter name.

    Parameters:
     - acl_counter: AccessListCounter. Requiredness: required.
    """
    pass

  def AccessListCounterClear(self, acl_counter):
    """
    Few points to note with this API. Currently only 1 counter get is supported.
    The counter name is expected to be fully resolved. For eg. for term specific policer counter
    it is expected to be passed to full counter name.

    Parameters:
     - acl_counter: AccessListCounter. Requiredness: required.
    """
    pass


class Client(Iface):
  """
  Firewall Service APIs
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def AccessListAdd(self, acl):
    """
    Adds an ACL and returns the result.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    self.send_AccessListAdd(acl)
    return self.recv_AccessListAdd()

  def send_AccessListAdd(self, acl):
    self._oprot.writeMessageBegin('AccessListAdd', TMessageType.CALL, self._seqid)
    args = AccessListAdd_args()
    args.acl = acl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListAdd(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListAdd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListAdd failed: unknown result");

  def AccessListDelete(self, acl):
    """
    Delete an ACL from the system and return the result.
    For successful delete to happen, the ACL should not be bound to any object.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    self.send_AccessListDelete(acl)
    return self.recv_AccessListDelete()

  def send_AccessListDelete(self, acl):
    self._oprot.writeMessageBegin('AccessListDelete', TMessageType.CALL, self._seqid)
    args = AccessListDelete_args()
    args.acl = acl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListDelete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListDelete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListDelete failed: unknown result");

  def AccessListChange(self, acl):
    """
    Changes an ACL based on the list of ACL entries provided, and returns the result.
    It is advisable to use this API to for small incremental changes. For wholesale
    changes, it is recommended to use the 'Replace' version of the API.

    Parameters:
     - acl: AccessList. Requiredness: required.
    """
    self.send_AccessListChange(acl)
    return self.recv_AccessListChange()

  def send_AccessListChange(self, acl):
    self._oprot.writeMessageBegin('AccessListChange', TMessageType.CALL, self._seqid)
    args = AccessListChange_args()
    args.acl = acl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListChange(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListChange_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListChange failed: unknown result");

  def AccessListBindAdd(self, bind_obj):
    """
    Add a binding of an ACL with a bind object and return the result.

    Parameters:
     - bind_obj: Bind object
    """
    self.send_AccessListBindAdd(bind_obj)
    return self.recv_AccessListBindAdd()

  def send_AccessListBindAdd(self, bind_obj):
    self._oprot.writeMessageBegin('AccessListBindAdd', TMessageType.CALL, self._seqid)
    args = AccessListBindAdd_args()
    args.bind_obj = bind_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListBindAdd(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListBindAdd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListBindAdd failed: unknown result");

  def AccessListBindDelete(self, bind_obj):
    """
    Deletes a binding of an ACL with a bind object and return the result.

    Parameters:
     - bind_obj: Bind object
    """
    self.send_AccessListBindDelete(bind_obj)
    return self.recv_AccessListBindDelete()

  def send_AccessListBindDelete(self, bind_obj):
    self._oprot.writeMessageBegin('AccessListBindDelete', TMessageType.CALL, self._seqid)
    args = AccessListBindDelete_args()
    args.bind_obj = bind_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListBindDelete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListBindDelete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListBindDelete failed: unknown result");

  def AccessListPolicerAdd(self, policer):
    """
    Adds a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    self.send_AccessListPolicerAdd(policer)
    return self.recv_AccessListPolicerAdd()

  def send_AccessListPolicerAdd(self, policer):
    self._oprot.writeMessageBegin('AccessListPolicerAdd', TMessageType.CALL, self._seqid)
    args = AccessListPolicerAdd_args()
    args.policer = policer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListPolicerAdd(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListPolicerAdd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListPolicerAdd failed: unknown result");

  def AccessListPolicerReplace(self, policer):
    """
    Changes a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    self.send_AccessListPolicerReplace(policer)
    return self.recv_AccessListPolicerReplace()

  def send_AccessListPolicerReplace(self, policer):
    self._oprot.writeMessageBegin('AccessListPolicerReplace', TMessageType.CALL, self._seqid)
    args = AccessListPolicerReplace_args()
    args.policer = policer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListPolicerReplace(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListPolicerReplace_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListPolicerReplace failed: unknown result");

  def AccessListPolicerDelete(self, policer):
    """
    Deletes a policer and returns the result.

    Parameters:
     - policer: AccessList type. Requiredness: required.
    """
    self.send_AccessListPolicerDelete(policer)
    return self.recv_AccessListPolicerDelete()

  def send_AccessListPolicerDelete(self, policer):
    self._oprot.writeMessageBegin('AccessListPolicerDelete', TMessageType.CALL, self._seqid)
    args = AccessListPolicerDelete_args()
    args.policer = policer
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListPolicerDelete(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListPolicerDelete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListPolicerDelete failed: unknown result");

  def AccessListCounterGet(self, acl_counter):
    """
    Few points to note with this API.
    The call is going to be blocking for worst case of 10 seconds which is non configurable.
    The counter name is expected to be fully resolved. For eg. for term specific policer counter
    it is expected to be passed to full counter name.

    Parameters:
     - acl_counter: AccessListCounter. Requiredness: required.
    """
    self.send_AccessListCounterGet(acl_counter)
    return self.recv_AccessListCounterGet()

  def send_AccessListCounterGet(self, acl_counter):
    self._oprot.writeMessageBegin('AccessListCounterGet', TMessageType.CALL, self._seqid)
    args = AccessListCounterGet_args()
    args.acl_counter = acl_counter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListCounterGet(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListCounterGet_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListCounterGet failed: unknown result");

  def AccessListCounterClear(self, acl_counter):
    """
    Few points to note with this API. Currently only 1 counter get is supported.
    The counter name is expected to be fully resolved. For eg. for term specific policer counter
    it is expected to be passed to full counter name.

    Parameters:
     - acl_counter: AccessListCounter. Requiredness: required.
    """
    self.send_AccessListCounterClear(acl_counter)
    return self.recv_AccessListCounterClear()

  def send_AccessListCounterClear(self, acl_counter):
    self._oprot.writeMessageBegin('AccessListCounterClear', TMessageType.CALL, self._seqid)
    args = AccessListCounterClear_args()
    args.acl_counter = acl_counter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_AccessListCounterClear(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = AccessListCounterClear_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "AccessListCounterClear failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["AccessListAdd"] = Processor.process_AccessListAdd
    self._processMap["AccessListDelete"] = Processor.process_AccessListDelete
    self._processMap["AccessListChange"] = Processor.process_AccessListChange
    self._processMap["AccessListBindAdd"] = Processor.process_AccessListBindAdd
    self._processMap["AccessListBindDelete"] = Processor.process_AccessListBindDelete
    self._processMap["AccessListPolicerAdd"] = Processor.process_AccessListPolicerAdd
    self._processMap["AccessListPolicerReplace"] = Processor.process_AccessListPolicerReplace
    self._processMap["AccessListPolicerDelete"] = Processor.process_AccessListPolicerDelete
    self._processMap["AccessListCounterGet"] = Processor.process_AccessListCounterGet
    self._processMap["AccessListCounterClear"] = Processor.process_AccessListCounterClear

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_AccessListAdd(self, seqid, iprot, oprot):
    args = AccessListAdd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListAdd_result()
    result.success = self._handler.AccessListAdd(args.acl)
    oprot.writeMessageBegin("AccessListAdd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListDelete(self, seqid, iprot, oprot):
    args = AccessListDelete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListDelete_result()
    result.success = self._handler.AccessListDelete(args.acl)
    oprot.writeMessageBegin("AccessListDelete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListChange(self, seqid, iprot, oprot):
    args = AccessListChange_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListChange_result()
    result.success = self._handler.AccessListChange(args.acl)
    oprot.writeMessageBegin("AccessListChange", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListBindAdd(self, seqid, iprot, oprot):
    args = AccessListBindAdd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListBindAdd_result()
    result.success = self._handler.AccessListBindAdd(args.bind_obj)
    oprot.writeMessageBegin("AccessListBindAdd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListBindDelete(self, seqid, iprot, oprot):
    args = AccessListBindDelete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListBindDelete_result()
    result.success = self._handler.AccessListBindDelete(args.bind_obj)
    oprot.writeMessageBegin("AccessListBindDelete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListPolicerAdd(self, seqid, iprot, oprot):
    args = AccessListPolicerAdd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListPolicerAdd_result()
    result.success = self._handler.AccessListPolicerAdd(args.policer)
    oprot.writeMessageBegin("AccessListPolicerAdd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListPolicerReplace(self, seqid, iprot, oprot):
    args = AccessListPolicerReplace_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListPolicerReplace_result()
    result.success = self._handler.AccessListPolicerReplace(args.policer)
    oprot.writeMessageBegin("AccessListPolicerReplace", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListPolicerDelete(self, seqid, iprot, oprot):
    args = AccessListPolicerDelete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListPolicerDelete_result()
    result.success = self._handler.AccessListPolicerDelete(args.policer)
    oprot.writeMessageBegin("AccessListPolicerDelete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListCounterGet(self, seqid, iprot, oprot):
    args = AccessListCounterGet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListCounterGet_result()
    result.success = self._handler.AccessListCounterGet(args.acl_counter)
    oprot.writeMessageBegin("AccessListCounterGet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_AccessListCounterClear(self, seqid, iprot, oprot):
    args = AccessListCounterClear_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = AccessListCounterClear_result()
    result.success = self._handler.AccessListCounterClear(args.acl_counter)
    oprot.writeMessageBegin("AccessListCounterClear", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class AccessListAdd_args:
  """
  Attributes:
   - acl: AccessList. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl', (AccessList, AccessList.thrift_spec), None, ), # 1
  )

  def __init__(self, acl=None,):
    self.acl = acl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl = AccessList()
          self.acl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListAdd_args')
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.STRUCT, 1)
      self.acl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListAdd_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListAdd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListDelete_args:
  """
  Attributes:
   - acl: AccessList. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl', (AccessList, AccessList.thrift_spec), None, ), # 1
  )

  def __init__(self, acl=None,):
    self.acl = acl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl = AccessList()
          self.acl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListDelete_args')
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.STRUCT, 1)
      self.acl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListDelete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListDelete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListChange_args:
  """
  Attributes:
   - acl: AccessList. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl', (AccessList, AccessList.thrift_spec), None, ), # 1
  )

  def __init__(self, acl=None,):
    self.acl = acl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl = AccessList()
          self.acl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListChange_args')
    if self.acl is not None:
      oprot.writeFieldBegin('acl', TType.STRUCT, 1)
      self.acl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListChange_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListChange_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListBindAdd_args:
  """
  Attributes:
   - bind_obj: Bind object
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bind_obj', (AccessListObjBind, AccessListObjBind.thrift_spec), None, ), # 1
  )

  def __init__(self, bind_obj=None,):
    self.bind_obj = bind_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bind_obj = AccessListObjBind()
          self.bind_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListBindAdd_args')
    if self.bind_obj is not None:
      oprot.writeFieldBegin('bind_obj', TType.STRUCT, 1)
      self.bind_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListBindAdd_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListBindAdd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListBindDelete_args:
  """
  Attributes:
   - bind_obj: Bind object
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bind_obj', (AccessListObjBind, AccessListObjBind.thrift_spec), None, ), # 1
  )

  def __init__(self, bind_obj=None,):
    self.bind_obj = bind_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bind_obj = AccessListObjBind()
          self.bind_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListBindDelete_args')
    if self.bind_obj is not None:
      oprot.writeFieldBegin('bind_obj', TType.STRUCT, 1)
      self.bind_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListBindDelete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListBindDelete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerAdd_args:
  """
  Attributes:
   - policer: AccessList type. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'policer', (AccessListPolicer, AccessListPolicer.thrift_spec), None, ), # 1
  )

  def __init__(self, policer=None,):
    self.policer = policer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.policer = AccessListPolicer()
          self.policer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerAdd_args')
    if self.policer is not None:
      oprot.writeFieldBegin('policer', TType.STRUCT, 1)
      self.policer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerAdd_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerAdd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerReplace_args:
  """
  Attributes:
   - policer: AccessList type. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'policer', (AccessListPolicer, AccessListPolicer.thrift_spec), None, ), # 1
  )

  def __init__(self, policer=None,):
    self.policer = policer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.policer = AccessListPolicer()
          self.policer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerReplace_args')
    if self.policer is not None:
      oprot.writeFieldBegin('policer', TType.STRUCT, 1)
      self.policer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerReplace_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerReplace_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerDelete_args:
  """
  Attributes:
   - policer: AccessList type. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'policer', (AccessListPolicer, AccessListPolicer.thrift_spec), None, ), # 1
  )

  def __init__(self, policer=None,):
    self.policer = policer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.policer = AccessListPolicer()
          self.policer.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerDelete_args')
    if self.policer is not None:
      oprot.writeFieldBegin('policer', TType.STRUCT, 1)
      self.policer.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListPolicerDelete_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListPolicerDelete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounterGet_args:
  """
  Attributes:
   - acl_counter: AccessListCounter. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl_counter', (AccessListCounter, AccessListCounter.thrift_spec), None, ), # 1
  )

  def __init__(self, acl_counter=None,):
    self.acl_counter = acl_counter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl_counter = AccessListCounter()
          self.acl_counter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounterGet_args')
    if self.acl_counter is not None:
      oprot.writeFieldBegin('acl_counter', TType.STRUCT, 1)
      self.acl_counter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounterGet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListCounterVal, AccessListCounterVal.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListCounterVal()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounterGet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounterClear_args:
  """
  Attributes:
   - acl_counter: AccessListCounter. Requiredness: required.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'acl_counter', (AccessListCounter, AccessListCounter.thrift_spec), None, ), # 1
  )

  def __init__(self, acl_counter=None,):
    self.acl_counter = acl_counter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.acl_counter = AccessListCounter()
          self.acl_counter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounterClear_args')
    if self.acl_counter is not None:
      oprot.writeFieldBegin('acl_counter', TType.STRUCT, 1)
      self.acl_counter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccessListCounterClear_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessListReturnStatus, AccessListReturnStatus.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessListReturnStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccessListCounterClear_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
